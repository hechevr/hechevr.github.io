<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="It works on my machine">
<meta property="og:type" content="website">
<meta property="og:title" content="404 Not Found">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="404 Not Found">
<meta property="og:description" content="It works on my machine">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="404 Not Found">
<meta name="twitter:description" content="It works on my machine">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>404 Not Found</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">404 Not Found</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/09/Select-poll-epoll/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李书赫">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404 Not Found">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/09/Select-poll-epoll/" itemprop="url">Select_poll_epoll</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-09T00:09:55+08:00">
                2019-07-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h3><p><img src="select.png" alt></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, fd_set* readfds, fd_set* writefds, fd_set* exceptfds, struct timeval* timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<p>监控三组descriptor。并且block进程，如果有descriptor数据就绪，则返回。<br>使用时需要遍历descriptor list。<br>缺点：</p>
<ol>
<li>每次调用select，需要把fd集合从用户空间拷贝到kernel，开销会随着fd增多而增大。</li>
<li>调用select都需要在内核便利传递来的所有fd，开销会随着fd增多增大。</li>
<li>支持文件描述符数量较小。</li>
</ol>
<h3 id="Poll"><a href="#Poll" class="headerlink" title="Poll"></a>Poll</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd* fds, <span class="keyword">nfds_t</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<p>相对于select的优点：</p>
<ol>
<li>集合了所有descriptor。</li>
<li>没有文件描述符数量的限制。<br>缺点：在fds很大时效率很低。和select没有本质区别。</li>
</ol>
<h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event* events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event* event)</span></span>;</span><br></pre></td></tr></table></figure>

<p>每次注册新事件时，会把所有的fd拷贝进内核，因此，每个fd在整个过程中会被拷贝一次。<br>在epoll_ctl时会把current遍历一遍，为每一个fd制定回调函数。当设备就绪时，回调函数会被call（把就绪的fd加入就绪链表）。<br>epoll_wait的工作是查看就绪链表，因此不需要每次新设备出现时都便利fd。</p>
<p>mmap：内存映射文件。文件磁盘地址和进程虚拟地址空间中一段虚拟地址一一对应。内核空间对文件的修改直接反应用户空间，可以实现不同进程间的文件共享。<br>epoll就用了mmap，所以速度会快一些。</p>
<p><img src="select_poll_epoll.png" alt></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/03/project/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李书赫">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404 Not Found">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/03/project/" itemprop="url">project</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-03T21:25:37+08:00">
                2019-07-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/玩具/" itemprop="url" rel="index">
                    <span itemprop="name">玩具</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>一时兴起决定写写爬虫来当学生项目。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">url = <span class="string">"http://www.qiushibaike.com/"</span></span><br><span class="line">tag = <span class="string">"hot/page/1"</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">'User-Agent'</span>: <span class="string">'User-Agent:Mozilla/5.0'</span></span><br><span class="line">&#125;</span><br><span class="line">request = urllib.request.Request(url+tag, headers=headers)</span><br><span class="line">response = urllib.request.urlopen(request)</span><br><span class="line">content = response.read()</span><br><span class="line">content_utf8 = content.decode(<span class="string">'utf-8'</span>)</span><br><span class="line"></span><br><span class="line">restr = <span class="string">'&lt;div class="article.*?&lt;div class="author.*?&lt;h2&gt;(.*?)&lt;/h2&gt;.*?&lt;/div&gt;.*?href="/article/(.*?)".*?&lt;span&gt;(.*?)&lt;/span&gt;.*?&lt;/div&gt;'</span></span><br><span class="line">pattern = re.compile(restr, re.S)</span><br><span class="line">items = re.findall(pattern, content_utf8)</span><br><span class="line">write_html(content)</span><br></pre></td></tr></table></figure>

<p>扒了糗事百科首页上的作者，链接。<br>目前打算是写一个自动爬段子分类推送的系统。然而发现现在的网站都坏坏，一个个的都不给人爬了。一会限制访问一会网站验证的。任重而道远啊。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/28/computer-system/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李书赫">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404 Not Found">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/28/computer-system/" itemprop="url">computer system</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-28T23:54:50+08:00">
                2019-06-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Reference: comptuer system: a programmer’s perspective<br>Related course: <a href="https://ipads.se.sjtu.edu.cn/courses/ics/" target="_blank" rel="noopener">Introduction to computer systems</a></p>
<h3 id="Memory-hierarchy"><a href="#Memory-hierarchy" class="headerlink" title="Memory hierarchy"></a>Memory hierarchy</h3><p>memory = RAM + ROM + Hard Disk</p>
<h4 id="RAM"><a href="#RAM" class="headerlink" title="RAM"></a>RAM</h4><p>RAM = DRAM + SRAM<br>RAM is volatile memories -&gt; loss data if powered off</p>
<table>
<thead>
<tr>
<th>category</th>
<th>transistor per bit</th>
<th>access time</th>
<th>persist</th>
<th>sensitive</th>
<th>cost</th>
<th>applications</th>
</tr>
</thead>
<tbody><tr>
<td>SRAM</td>
<td>6</td>
<td>fastest</td>
<td>yes</td>
<td>no</td>
<td>expensive</td>
<td>cache</td>
</tr>
<tr>
<td>DRAM</td>
<td>1</td>
<td>fast</td>
<td>no</td>
<td>yes</td>
<td>less exp</td>
<td>main memories</td>
</tr>
</tbody></table>
<h4 id="ROM"><a href="#ROM" class="headerlink" title="ROM"></a>ROM</h4><p>ROM is nonvolatile memories<br>ROM:BIOS, graphics card, disk controllers</p>
<p>Hard disk = several platters<br>platter = 2 surfaces<br>surface = multiple tracks<br>track = lots of sectors</p>
<p>Access time = seek time (seek for track) + rotation time (wait for sector) + transfer time (data transfer)<br>Example: T = 9ms + 4ms + 0.02ms -&gt; seek time and rotation time dominate the access time.</p>
<p>I/O port: address reserved for the communication between cpu and I/O device.</p>
<p>Routine for cpu access disk:</p>
<ol>
<li>cpu initiates a disk read by writing a command, logical block number and destination memory address to a port</li>
<li>Disk controller reads sector and perform a DMA (no CPU) transfer into main memory(RAM).</li>
<li>Disk controller send interrupt to cpu. (could be singal in pin or information on bus).</li>
<li>CPU read from memory.</li>
</ol>
<p><img src="architecture.png" alt></p>
<h4 id="SSD"><a href="#SSD" class="headerlink" title="SSD"></a>SSD</h4><p>SSD stands for Solid State Disk. It is a storage technology based on flash memory.<br>Charasteristic of SSD: </p>
<ol>
<li>Data read/write in units of pages(pages form block)</li>
<li>Page can be written only after the blocks are erased.</li>
<li>Could be wears out.</li>
<li>No moving part-&gt;faster, less power.</li>
</ol>
<p>The gap between the speed of CPU and memory is widthen. We use locality and memory hierarchy to decrease the time of memory process.<br>Locality: Pragrams tend to use data and instructions with address near or equal to those they have used recently.<br>Temporal locality: recently used.<br>Spatial locality: nearby.</p>
<p>![](memory_hierarchy.png]<br>Memory hierarchy: Register-&gt;L1, L2, L3 cache(SRAM)-&gt;Main memory(DRAM)-&gt;Local disks.<br>Low level memory serves as caches for high level memory.<br>Because of the locality, hierarchy memory could be a good solution for fasten the progress on memory.</p>
<p>Generic Cache memory organization:<br>cache = sets = valid(1bit) + tag(block index in physical memory) + blocks<br>physical address = tag(block index) + set index + block offset</p>
<p>physical address -&gt; cache:<br>select set -&gt; Line matching(valid number, tag) -&gt; word extraction(according to block offset)</p>
<h3 id="Read"><a href="#Read" class="headerlink" title="Read"></a>Read</h3><p>conflict-&gt;same cache lines will be filled by different physical address multiple times.</p>
<p>Why using middle bits as index? the middle bits will make the physical memory caches mapping more fluent. Consecutive memory lines map to different caches lines.</p>
<p>To find the lines in same set. Using tags.</p>
<p>The physical memory will only determine which sets will be used. If all the lines in the same sets are filled, which line will be evicted?<br>LFU: least frequently used.<br>LRU: least recently used.</p>
<p>Set associative caches: several sets. each set contains several lines.<br>Fully associative caches: one sets. contain all the lines.</p>
<h3 id="Write"><a href="#Write" class="headerlink" title="Write"></a>Write</h3><p>Modern Implementation: write back, write allocate<br>write through: cpu write into caches and copy data from caches into memory.<br>write back: cpu write into caches, copy data into memory only if the caches will be evicted.<br>write allocate: land the corrend memory block into cache, then updates the cache block.<br>no-write-allocate: bypass the cache and write toe word directly memory.</p>
<p>Miss rate: memory not found in cache. 3-10% for L1. can be small for L2.<br>Hit rate: fraction of memory found in cache(1-Miss rage).<br>Hit time: time to deliver a line in the cache to processor.<br>Miss Penalty: additional time required because of a miss.</p>
<p>How to write cache-frendly code? better locality. lower miss rates.<br>Temporal locality: repeated references to local variables-&gt;compiler will cache the data in register.<br>Spatial locality: stride-1 references patterns-&gt;contiguous blocks will be stored in caches.</p>
<p><img src="cpu_architecture.jpg" alt></p>
<h3 id="Linking"><a href="#Linking" class="headerlink" title="Linking"></a>Linking</h3><p>Linking can be performed 1. at compile time(static linking). 2. at load time(load time dynamic linking). 3. at run time(run-time dynamic link).<br>compiling: preprocessor(cpp), compiler(cc1), assembler(as), linker(ld).</p>
<h4 id="Static-Linking"><a href="#Static-Linking" class="headerlink" title="Static Linking"></a>Static Linking</h4><p>relocatable object files(*.o) -&gt; Fully linked executable object<br>Esternal reference: reference to a symbol defined in another object file. (values close to 0).<br>Symbol resolution: resolved external references.</p>
<h4 id="Dynamic-linking"><a href="#Dynamic-linking" class="headerlink" title="Dynamic linking"></a>Dynamic linking</h4><p>DLL/so files that will be load at run time or load time. For load time dynamic linking, there is a stub in the binary code that tell the system to load some resource from the shared library. Only after the resource is loaded, the program will start to run.<br>Run-time dynamic linking do not ask system to load resource at load time. In windows, GetProcAddress API will load the library at run time.</p>
<h4 id="Executable-and-linkable-format"><a href="#Executable-and-linkable-format" class="headerlink" title="Executable and linkable format"></a>Executable and linkable format</h4><p>standard binary format for object files. Unified format for relocatable object(.o), executable object files and shared object files(.so).</p>
<h4 id="Command-in-GCC"><a href="#Command-in-GCC" class="headerlink" title="Command in GCC"></a>Command in GCC</h4><p>Create dynamic library in GCC:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared hello.c -o libhello.so</span><br></pre></td></tr></table></figure>

<p>Link libhello.so to executable:<br>-l link library. -L library position. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc test.c -lhello -L.</span><br></pre></td></tr></table></figure>

<p>create static library in GCC:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c hello.c -o libhello.o</span><br></pre></td></tr></table></figure>

<p>Link libhello.o to executable:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc test.c libhello.o</span><br></pre></td></tr></table></figure>

<h3 id="Operating-system"><a href="#Operating-system" class="headerlink" title="Operating system"></a>Operating system</h3><p>Abstractions provided by OS<br><img src="os_abstractions.png" alt></p>
<h4 id="classes-of-exceptions"><a href="#classes-of-exceptions" class="headerlink" title="classes of exceptions"></a>classes of exceptions</h4><h5 id="synchronous-exceptions"><a href="#synchronous-exceptions" class="headerlink" title="synchronous exceptions"></a>synchronous exceptions</h5><p>caused by events as the result of executing an instruction.</p>
<h6 id="traps"><a href="#traps" class="headerlink" title="traps"></a>traps</h6><p>intentional. returns control to next instruction. (breakpoint)</p>
<h6 id="faults"><a href="#faults" class="headerlink" title="faults"></a>faults</h6><p>unintentional but possibly recoverable. page faults.<br>page fault: the memory address requested is not available.<br>case 1: the address is invalid -&gt; segmentation fault(SIGSEG).<br>case 2(minor): the page is loaded in memory but it is not marked in memory management unit -&gt; register in MMU.<br>case 3(major): the page is not loaded -&gt; load page from disk.</p>
<p>For case 1, the OS will send SIGSEG to the process and terminate the process. Thus unrecoverable.<br>For case2, case 3, the OS will do the corresponding handle and return the instructions points. Thus the instruction will do again.</p>
<h6 id="aborts"><a href="#aborts" class="headerlink" title="aborts"></a>aborts</h6><p>unintentional and unrecoverable. parity error.</p>
<h5 id="Asynchronous-exceptions"><a href="#Asynchronous-exceptions" class="headerlink" title="Asynchronous exceptions"></a>Asynchronous exceptions</h5><p>caused by events external to the processor.<br>Examples: 1. IO interrupts(ctrl-c). 2. hard reset interrupt(reset button). 3. soft reset interrupt(ctrl-alt-delete).<br><img src="fault.png" alt></p>
<h3 id="process"><a href="#process" class="headerlink" title="process"></a>process</h3><p>scheduler(parts of kernel) will do following things.</p>
<ol>
<li>decides whether to preempt the current process</li>
<li>selects a previously preempted process</li>
<li>preempts the current process</li>
<li>restart the scheduled process</li>
</ol>
<p>In order to restart the preempted process, context need to be stored.<br>context contains: </p>
<ol>
<li>cpu (register, value, status)</li>
<li>kernel (environment valiables, process table, page table, file table)</li>
<li>memory (user’s stack, kernel’s stack, code, data)</li>
</ol>
<p>context switch:</p>
<ol>
<li>system call(read, sleep)</li>
<li>timer interrupt (scheduler)</li>
</ol>
<table>
<thead>
<tr>
<th>process status</th>
<th>action</th>
</tr>
</thead>
<tbody><tr>
<td>stop</td>
<td>receiving a signal(SIGSTOP, SIGTSTP, SITTTIN, SIGTTOU)</td>
</tr>
<tr>
<td>running</td>
<td>receiving a SIGCONT</td>
</tr>
<tr>
<td>terminated</td>
<td>exit(), return from main, signal</td>
</tr>
</tbody></table>
<p>fork(void): return 0 to child, PID to parent, -1 for error.<br>clone all the data in parent process except pid.</p>
<p>two process can share files for communicate. (stdout)</p>
<h4 id="Zombie"><a href="#Zombie" class="headerlink" title="Zombie"></a>Zombie</h4><p>A terminated child process will become zombie if the parent has not reaped.<br>If the parent process has be terminated, kernel will assign init (pid=1) to reap them.</p>
<p>Zombie will consume system memory resources -&gt; always reap zombies.</p>
<h4 id="Process-related-API"><a href="#Process-related-API" class="headerlink" title="Process related API"></a>Process related API</h4><p>pid_t waitpid(pid_t pid, int *status, int options);<br>pid_t wait(int *status);</p>
<p>if pid &gt; 0, the process will wait for specific child.<br>if pid = -1, the process will wait any child.<br>if there is no children, return -1. errno=ECHILD(the process has no child), errno=(EINTR)interrupted by a signal.<br>options = 0. </p>
<p>unsigned int sleep(unsigned int secs);<br>int pause(void);</p>
<p>int execve(const char* filename, const char* argv[], const char* envp[]);<br>if something wrong, return -1. otherwise, never return.<br>The new program will use the same process resource. The running stack will be replaced.</p>
<h4 id="unix-shell"><a href="#unix-shell" class="headerlink" title="unix shell"></a>unix shell</h4><p>application level program.<br>compare: kernel is the core of OS whoes jobs are managing the hardware resource. </p>
<p>variants of shell: bash, sh, csh, tcsh.</p>
<p>performs a sequence of read/evaluate steps and terminate. read: reads a command line. evalute: parse the command line and runs programs.</p>
<h3 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h3><h4 id="System-level-I-O-UNIX-IO"><a href="#System-level-I-O-UNIX-IO" class="headerlink" title="System-level I/O (UNIX IO)"></a>System-level I/O (UNIX IO)</h4><p>In Unix, all IO devices are modeled as files.<br>A socket is a file that is used to communicate with another process across a network. (other types include named pips, symbolic links, character and block devices)</p>
<p>Kernal data structure for files<br>Descriptor table: every process has one. index is descriptor, point to file table.<br>File table: opened file has one or more, shared by all process. file position, reference count, pointer to V-node table.<br>V-node table: every file has one, shared by all process. file type, file size, file access.</p>
<p>Normally, one descriptor in descriptor table corresponding to one file table(different descriptor corresponding to same file will not conflect).<br>However, dup2(fd1, fd2) will assign file table(fd1) to file table(fd2).</p>
<p>File table will be deleted by kernel if recerence count is zero.</p>
<p>Open files<br>Appication: announce intention to access an I/O device. However, the application will only keep track of descriptor. it can set the current file position explicitly by performing a seek operation.<br>Kernal: open the file, returns a small non-negative integer descriptor. keeps track of all information about the open file.<br>EOF: there is no EOF in files. It is just a condition triggered if the requested byte is more than bytes left to the end.</p>
<p>Close files:<br>application: will not access the file.<br>kernel: frees structures. restore the descriptor to a pool of available descriptor.</p>
<h4 id="RIO-Robust-IO"><a href="#RIO-Robust-IO" class="headerlink" title="RIO (Robust IO)"></a>RIO (Robust IO)</h4><p>wrappers that provide efficient and robust IO.<br>with no buff: read/write automatic deal with EINTR. EOF will return size instead of 0.<br>buff: read/write to buff. less read/write command-&gt;better performance.<br>rio_readn(int fd, void *usrbuf, size_t count)<br>rio_writen(int fd, void *usrbuf, size_t count)</p>
<h4 id="standard-IO"><a href="#standard-IO" class="headerlink" title="standard IO"></a>standard IO</h4><p>C standard library (libc.so). high level standard io.<br>abstract open files as streams -&gt; file descriptor and a buffer.<br>stdin(fd=0)<br>stdout(fd=1)<br>stderr(fd=2)<br>Similar to RIO.</p>
<pre><code>|Unix IO|standard io</code></pre><p>—–|——-|———–<br>prons|general, lowest over head. Metadata, async-signal-safe|efficiency. automatically short counts<br>cons |Shord counts is tricky and error prone. inefficient   |no metadata. not async-signal-safe. not good for network sockets</p>
<p>note: standard IO require fflush/fseek/fsetpos/rewind between write and read.</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/28/bignumber/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李书赫">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404 Not Found">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/28/bignumber/" itemprop="url">大数相乘以及快速幂</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-28T11:59:52+08:00">
                2019-06-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/基础知识/" itemprop="url" rel="index">
                    <span itemprop="name">基础知识</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>宏观上，我们认为数的相乘为constant time，即O(1). 然而，如果考虑到数的位数，那么乘法操作就变得复杂起来。<br>如果两个长度为N的数相乘，小学所讲的乘法运算复杂度为O(n^2) –&gt; 对每一位都要进行相乘运算。<br>另一个方法是karatsuba。<br><img src="bidnumber.png" alt><br>如图所示，基础思想为divide and conquer。<br>以下为c++代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_length</span><span class="params">(<span class="keyword">long</span> num)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		num /= <span class="number">10</span>;</span><br><span class="line">		length++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">karatsuba</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">long</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// x = a * 10^(length/2) + b</span></span><br><span class="line">	<span class="comment">// y = c * 10^(length/2) + d</span></span><br><span class="line">	<span class="comment">// x * y = ac * 10^length + bd + ((a + c)*(b + d) - ac - bd)*10^(length/2)</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (x &lt; <span class="number">10</span> &amp;&amp; y &lt; <span class="number">10</span>) <span class="keyword">return</span> x * y;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// calculate a b c d</span></span><br><span class="line">	<span class="keyword">int</span> length = max(get_length(x), get_length(y));</span><br><span class="line">	<span class="keyword">int</span> t = <span class="built_in">pow</span>(<span class="number">10</span>, length / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> a = x / t;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> b = x - a * t;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> c = y / t;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> d = y - c * t;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// z1 = ac, z2 = bd, z3 = (a+c)*(b+d) - z1 - z2</span></span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> z1 = karatsuba(a, c);</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> z2 = karatsuba(b, d);</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> z3 = karatsuba((a + b), (c + d)) - z1 - z2;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> z1 * t*t + z2 + z3 * t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在写代码的时候，发现使用long并不会扩张int的取值范围。于是去百度，发现，long的位数由编译器来确定，c语言只规定long位数不低于int。<br>而我使用的VC，把long定义为4字节，同int一样。</p>
<p>快速幂：<br>求幂的时候，我们也可以用divide and conquer来缩短运算。如果把相乘看为O(1)，求N次幂显然需要O(N)次运算。<br>然而，我们可以让底数增大，这样相乘的次数就会减少。例如$2^4 = 2^2 * 2^2$.<br>于是，运算可以简化为O(logN)<br>以下是相应代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">exp</span> = <span class="built_in">abs</span>(exponent);</span><br><span class="line">    <span class="keyword">double</span> res = <span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">exp</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">exp</span> &amp; <span class="number">1</span>) res *= base;</span><br><span class="line">        base *= base;</span><br><span class="line">        <span class="built_in">exp</span> &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> exponent &lt; <span class="number">0</span>? <span class="number">1</span>/res:res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/27/memory-in-c/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李书赫">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404 Not Found">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/27/memory-in-c/" itemprop="url">C/C++中的内存管理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-27T23:00:28+08:00">
                2019-06-27
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/基础知识/" itemprop="url" rel="index">
                    <span itemprop="name">基础知识</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在了解内存管理之前，需要注意C语言中变量类型。<br>const：常数变量。static：静态变量。<br>局部变量（函数内部）。全局变量（非函数内部）。</p>
<p><img src="5memory_area.png" alt><br>可执行文件(exe)文件中储存在disk时，可以分为代码区(code area)，数据区(data area)，未初始化数据区(BSS).<br>在执行时，在系统内存中会另外生成栈区(stack)和堆区(heap)。<br>代码区：存放执行代码。有可能包含一些只读的常数变量。<br>数据区：存放已初始化全局变量，静态变量和常量数据。<br>未初始化数据区(BSS)：用来存放未初始化的全局变量。在程序运行时会对全部变量赋值0。<br>栈区(stack)：存放局部变量以及程序运行时需要的信息（包括函数调用返回地址，传递参数）。由系统自动静态分配。<br>堆区(heap)：由程序员分配释放。（malloc/free）。</p>
<p>栈/堆区别：<br>栈由系统控制分配释放，硬件方面有相应的适配，故效率极高。高地址到低地址。<br>堆有程序员控制分配释放，在执行时可能会存在碎片，因此效率相对较低。低地址到高地址。</p>
<p>内存对齐：<br>不同平台对对内存空间处理上不同。一些平台对特定类型数据只能从特定地址开始存取。<br>内存对齐可以减少读取周期，增加效率。<br>有三条规则：</p>
<ol>
<li>对于结构体，成员偏移量(内存所在位置)应为当前成员类型整数倍。</li>
<li>结构体所有数据成员对齐后，本身还要对齐，保证整个结构体占用内存大小是结构体最大数据成员的最小整数倍。</li>
<li>#pragma pack(n) 预编译指令使得所有成员对齐以n字节为准，不考虑规则二。<br>举例：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BU1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> number;             <span class="comment">//4字节</span></span><br><span class="line">    <span class="keyword">union</span> UBffer</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> buffer[<span class="number">13</span>];    <span class="comment">//填充3字节，该成员占16字节空间</span></span><br><span class="line">        <span class="keyword">double</span> number;</span><br><span class="line">    &#125;ubuf;</span><br><span class="line">    <span class="keyword">int</span> aa;                 <span class="comment">//占4字节空间,当前偏移量已补齐为24</span></span><br><span class="line">    <span class="keyword">double</span> dou;             <span class="comment">//占8字节空间</span></span><br><span class="line">&#125;bu;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>sizeof(BU1) = 4 + 4(补充) + 13 + 3(补充) + 4 + 8 + 4(补充)</p>
<pre><code class="c"><span class="class"><span class="keyword">struct</span> <span class="title">BU2</span></span>
<span class="class">{</span>
    <span class="keyword">int</span> number;             <span class="comment">//4字节</span>
    <span class="keyword">union</span> UBffer
    {
        <span class="keyword">char</span> buffer[<span class="number">13</span>];    <span class="comment">//填充3字节，该成员占16字节空间</span>
        <span class="keyword">int</span> number;
    }ubuf;
    <span class="keyword">double</span> aa;                 <span class="comment">//占8字节空间,当前偏移量已补齐为24</span>
    <span class="keyword">int</span> dou;             <span class="comment">//占4字节空间</span>
}bu;</code></pre>
<p>sizeof(BU2) = 4 + 13 + 7(补充) + 8 + 4 + 4(补充)</p>
<p>注意，如果在代码首部加上#pragma pack(1)，sizeof(BU1) = 4 + 13 + 4 + 8, sizeof(BU2) = 4 + 13 + 8 + 4</p>
<p>柔性数组机制，如果最后一个成员为数组，且大小为0，则该结构体大小不计算该数组。<br>C++中，struct本质上是public class，规定空类大小为1.<br>C中，空类大小为0.</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/27/true-complemental-ones-complemental-code/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李书赫">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404 Not Found">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/27/true-complemental-ones-complemental-code/" itemprop="url">原码，反码，补码</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-27T11:32:47+08:00">
                2019-06-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在做题的时候遇到了相互转换的问题，于是在此做一个小结。<br>原码，即为数直接转换为二进制后的编码。负数与正数的差别为负数最高为为1，正数为0.<br>正数的反码和补码与原码相同。负数的反码为除最高位全部取反。负数的补码为反码加一。<br>如：<br>-5，原码1000 0101，反码1111 1010，补码1111 1011.<br>-0，原码1000 0000，反码1111 1111，补码0000 0000.</p>
<p>127 原码0111 1111，反码0111 1111，补码0111 1111.<br>-127 原码1111 1111，反码1000 0000，补码1000 0001.<br>我们发现，1000 0000这个状态没有使用。如果我们把它当作补码。<br>最高位为1，所以是负数，相应的反码0111 1111. 相应的原码1000 0000.<br>所以，1000 0000可以表示-128的补码。</p>
<p>因此，int（32位）取值范围为$-2^{32-1} – (2^{32-1}-1)$</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/26/practice/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李书赫">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404 Not Found">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/26/practice/" itemprop="url">剑指offer</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-26T23:16:15+08:00">
                2019-06-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/剑指offer/" itemprop="url" rel="index">
                    <span itemprop="name">剑指offer</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Link: [<a href="https://www.nowcoder.com/ta/coding-interviews]" target="_blank" rel="noopener">https://www.nowcoder.com/ta/coding-interviews]</a></p>
<h2 id="1-10"><a href="#1-10" class="headerlink" title="1 - 10"></a>1 - 10</h2><h3 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h3><p>看到题的直觉是用binary search。<br>先用暴力搜索–&gt;15ms + 1484k–&gt;O(n<em>m)<br>对每一行预先判断首尾–&gt;15ms + 1376k–&gt;O(n</em>m)<br>binary search–&gt;12 + 1504k–&gt;O(n*logm)<br>最后，发现矩阵整体是有序的，因此可以由左下开始直接判断,复杂度O(n+m)</p>
<p>PS: 设置的测试方案太过简单，直接暴力搜索也不是很慢。</p>
<p>附binary search代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = <span class="built_in">array</span>.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">array</span>[i][mid] == target)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">array</span>[i][mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">array</span>[i][mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h3><p>本题较为简单，直接从后往前扫描插入即可。（如果用js/python直接用replace就好了）</p>
<h3 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h3><p>本题较为简单，通过stack使得顺序改变即可。需要注意的是，这题head里面是存数据的。</p>
<h3 id="第四题"><a href="#第四题" class="headerlink" title="第四题"></a>第四题</h3><p>由前中/中后序重构树。使用递归完成较为简单。<br>前中：1. 前序第一个一定是本节的根。2. 找到本节根在中序的位置。3. 计算左树点的数量。<br>中后：1. 后序最后一个一定是本节的根。2. 找到本节根在中序的位置。3. 计算左数点的数量。<br>附前中序代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">R</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vin, <span class="keyword">int</span> preStart, <span class="keyword">int</span> preEnd, <span class="keyword">int</span> vinStart, <span class="keyword">int</span> vinEnd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (preStart &gt;= preEnd || vinStart &gt;= vinEnd) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// search the position in vin</span></span><br><span class="line">    <span class="keyword">int</span> vinPosition = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = vinStart; i &lt; vinEnd; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (vin[i] == pre[preStart]) &#123;</span><br><span class="line">        vinPosition = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> prePosition = preStart + vinPosition - vinStart;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">node</span> = <span class="title">new</span> <span class="title">struct</span> <span class="title">TreeNode</span>(<span class="title">pre</span>[<span class="title">preStart</span>]);</span></span><br><span class="line">    node-&gt;left = R(pre, vin, preStart+<span class="number">1</span>, prePosition+<span class="number">1</span>, vinStart, vinPosition);</span><br><span class="line">    node-&gt;right = R(pre, vin, prePosition+<span class="number">1</span>, preEnd, vinPosition+<span class="number">1</span>, vinEnd);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第五题"><a href="#第五题" class="headerlink" title="第五题"></a>第五题</h3><p>此题较为简单。stack1储存，stack2给予，如果stack2为空时将stack1的点全部输入stack2即可。</p>
<h3 id="第六题"><a href="#第六题" class="headerlink" title="第六题"></a>第六题</h3><p>旋转数组找最小成分。直观做法是线性扫描–&gt;37ms.<br>稍加观察，发现出现先第一个小于首位的数即为最小–&gt;32ms.</p>
<h3 id="第七题"><a href="#第七题" class="headerlink" title="第七题"></a>第七题</h3><p>斐波那契数列。</p>
<h3 id="第八题"><a href="#第八题" class="headerlink" title="第八题"></a>第八题</h3><p>斐波那契数列变种。$F(n) = F(n-1) + F(n-2)$</p>
<h3 id="第九题"><a href="#第九题" class="headerlink" title="第九题"></a>第九题</h3><p>斐波那契数列变种。$F(n) = \sum_{k=1}^{n-1} F(k)+1$</p>
<h3 id="第九题-1"><a href="#第九题-1" class="headerlink" title="第九题"></a>第九题</h3><p>斐波那契数列变种。$F(n) = F(n-1) + F(n-2)$</p>
<h3 id="第十题"><a href="#第十题" class="headerlink" title="第十题"></a>第十题</h3><p>求二进制中1的个数。比较麻烦的是负数。有关负数补码，可以参考另一篇博客“原码，反码和补码”。<br>其实这道题还可以直接对bit操作，会简单很多。但是我觉得出题人的初衷是要考察对原反补码的理解。whatever。以下是相关代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tag&amp;n) &#123;</span><br><span class="line">            res ++;</span><br><span class="line">        &#125;</span><br><span class="line">        tag = tag &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="11-20"><a href="#11-20" class="headerlink" title="11 - 20"></a>11 - 20</h2><h3 id="第十一题"><a href="#第十一题" class="headerlink" title="第十一题"></a>第十一题</h3><p>快速幂，增大base来减少相乘的次数。详细算法可以参考“大数相乘以及快速幂”。<br>其实直接用写好的pow即可快速通过。</p>
<h3 id="第十二题"><a href="#第十二题" class="headerlink" title="第十二题"></a>第十二题</h3><p>方法一：bubble sort。左偶数右奇数-&gt;交换。O(n^2).<br>方法二：新建vector。扫描奇数，扫描偶数。O(n)。</p>
<h3 id="第十三题"><a href="#第十三题" class="headerlink" title="第十三题"></a>第十三题</h3><p>方法一：遍历，得到list的大小，再次遍历，找到size-k。<br>方法二：使用stack，全部存下，然后pop k次。<br>方法三：使用queue，如果queue大于k，pop。<br>比较：我个人最喜欢方法三，只需要一次遍历并且存下k个node。属于折中的方法。</p>
<h3 id="第十四题"><a href="#第十四题" class="headerlink" title="第十四题"></a>第十四题</h3><p>最简单的方法是使用stack存下全部node，然后再根据stack的顺序新建node。然而需要遍历两遍，且需要新建一个list。<br>也可以直接操作list，需要记录前，中，后三点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">ReverseList</span><span class="params">(ListNode* pHead)</span> </span>&#123;</span><br><span class="line">    ListNode* pre = <span class="literal">NULL</span>;</span><br><span class="line">    ListNode* current = <span class="literal">NULL</span>;</span><br><span class="line">    ListNode* post = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    current = pHead;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        post = current-&gt;next;</span><br><span class="line">        current-&gt;next = pre;</span><br><span class="line">        pre = current;</span><br><span class="line">        current = post;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第十五题"><a href="#第十五题" class="headerlink" title="第十五题"></a>第十五题</h3><p>较为简单，不做赘述。</p>
<h3 id="第十六题"><a href="#第十六题" class="headerlink" title="第十六题"></a>第十六题</h3><p>主要是对递归的理解。分为两个function。sub判断tree2是否为当前tree1的顶端。HasSubtree判断tree1是否包含tree2. 代码下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">sub</span><span class="params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root2 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root1 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root1-&gt;val == root2-&gt;val) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sub(root1-&gt;left, root2-&gt;left) &amp;&amp; sub(root1-&gt;right, root2-&gt;right)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">HasSubtree</span><span class="params">(TreeNode* pRoot1, TreeNode* pRoot2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pRoot1 == <span class="literal">NULL</span> || pRoot2 == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// case 1: same root</span></span><br><span class="line">    <span class="keyword">if</span> (sub(pRoot1, pRoot2)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// case 2: left has sub tree</span></span><br><span class="line">    <span class="keyword">if</span> (pRoot1-&gt;left != <span class="literal">NULL</span> &amp;&amp; HasSubtree(pRoot1-&gt;left, pRoot2)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// case 3: right has sub tree</span></span><br><span class="line">    <span class="keyword">if</span> (pRoot1-&gt;right != <span class="literal">NULL</span> &amp;&amp; HasSubtree(pRoot1-&gt;right, pRoot2)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第十七题"><a href="#第十七题" class="headerlink" title="第十七题"></a>第十七题</h3><p>较为简单，使用DFS遍历，然后交换左右子树。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Mirror</span><span class="params">(TreeNode *pRoot)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// terminate condition</span></span><br><span class="line">    <span class="keyword">if</span> (pRoot == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// DFS</span></span><br><span class="line">    <span class="keyword">if</span> (pRoot-&gt;left != <span class="literal">NULL</span>) Mirror(pRoot-&gt;left);</span><br><span class="line">    <span class="keyword">if</span> (pRoot-&gt;right != <span class="literal">NULL</span>) Mirror(pRoot-&gt;right);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// swqp left and right</span></span><br><span class="line">    TreeNode* tmp = pRoot-&gt;left;</span><br><span class="line">    pRoot-&gt;left = pRoot-&gt;right;</span><br><span class="line">    pRoot-&gt;right = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第十八题"><a href="#第十八题" class="headerlink" title="第十八题"></a>第十八题</h3><p>比较麻烦的简单题。有四种不同状态，判断好边界就不是很难处理。</p>
<h3 id="第十九题"><a href="#第十九题" class="headerlink" title="第十九题"></a>第十九题</h3><p>题目要求要stack查找最小值时间复杂度为O(1)。很明显要储存一些数据来支持这个结构。那么我们需要储存什么呢？来看一下需求。要求最小值时间复杂度为1，且每次pop之后，重新寻找最小值也是O(1).设置一个一模一样的结构记录每一次pop后的最小值即可完成目标。<br>简单来说就是用两个stack，一个用来存放数据，一个用来存放最小值。当新的数值小于stack2.top时，我们将新的数值push到stack2中。</p>
<h3 id="第二十题"><a href="#第二十题" class="headerlink" title="第二十题"></a>第二十题</h3><p>本题比较有趣。如果判断某序列是否可以由stack pop出，可以根据“一旦pop，stack中剩余的元素相对order不可能改变”。<br>然而，本题如果用这种方式来判断，时间复杂度为O(n^2)。<br>我们可以模拟整个stack push pop的过程，如果最终stack为空，则该序列是合法的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsPopOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pushV,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; popV)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// simulate the situation</span></span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">int</span> popPos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pushV.size(); i++) &#123;</span><br><span class="line">        s.push(pushV[i]);</span><br><span class="line">        <span class="keyword">while</span> (popPos &lt; popV.size() &amp;&amp; s.top() == popV[popPos]) &#123;</span><br><span class="line">            s.pop();</span><br><span class="line">            popPos++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.empty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="21-30"><a href="#21-30" class="headerlink" title="21 - 30"></a>21 - 30</h2><h3 id="第二十一题"><a href="#第二十一题" class="headerlink" title="第二十一题"></a>第二十一题</h3><p>BFS。使用queue来储存即可。同理，使用stack可以实现DFS。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; PrintFromTopToBottom(TreeNode* root) &#123;</span><br><span class="line">    <span class="comment">// BFS</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">    q.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        TreeNode* node = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        res.push_back(node-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            q.push(node-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            q.push(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第二十二题"><a href="#第二十二题" class="headerlink" title="第二十二题"></a>第二十二题</h3><p>递归问题。判断一个序列是否为合法的二叉搜索树后序排列，针对每一个root点，判断其前面序列是否可以分为左树和右树。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sequence, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// sequence should be able to be splitted into 2 parts</span></span><br><span class="line">    <span class="keyword">int</span> pivot = sequence[right];</span><br><span class="line">    <span class="keyword">bool</span> isLeftPart = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = left;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt; right; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isLeftPart) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sequence[i] &gt; pivot) &#123;</span><br><span class="line">                isLeftPart = <span class="literal">false</span>; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                mid = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (sequence[i] &lt; pivot) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> check(sequence, left, mid) &amp;&amp; check(sequence, mid+<span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">VerifySquenceOfBST</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sequence)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = sequence.size();</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> check(sequence, <span class="number">0</span>, size<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第二十三题"><a href="#第二十三题" class="headerlink" title="第二十三题"></a>第二十三题</h3><p>简单的DFS。但是如果用非递归方法，需要维持一些数据结构且要判断边界，很麻烦。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; FindPath(TreeNode* root,<span class="keyword">int</span> expectNumber) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> res;</span><br><span class="line">        path.push_back(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val == expectNumber &amp;&amp; root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            res.push_back(path);</span><br><span class="line">        &#125;</span><br><span class="line">        FindPath(root-&gt;left, expectNumber-root-&gt;val);</span><br><span class="line">        FindPath(root-&gt;right, expectNumber-root-&gt;val);</span><br><span class="line">        path.pop_back();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="第二十四题"><a href="#第二十四题" class="headerlink" title="第二十四题"></a>第二十四题</h3><p>想破头的题。无论如何都找不到简单的方法，查看了人家的讲解，发现是在原本linked list上进行改动。感觉巧妙的同时也感慨自己的愚鲁。<br>此处附上偷来的讲解和自己的代码。<br><img src="q24.png" alt></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">RandomListNode* <span class="title">Clone</span><span class="params">(RandomListNode* pHead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pHead == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    RandomListNode* node = pHead;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// copy all the node alone path of next</span></span><br><span class="line">        RandomListNode* newnode = <span class="keyword">new</span> RandomListNode(node-&gt;label);</span><br><span class="line">        RandomListNode* tmp = node-&gt;next;</span><br><span class="line">        node-&gt;next = newnode;</span><br><span class="line">        newnode-&gt;next = tmp;</span><br><span class="line">        node = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    node = pHead;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// copy all the node alone path of random</span></span><br><span class="line">        RandomListNode* targetNode = node-&gt;random;</span><br><span class="line">        <span class="keyword">if</span> (targetNode != <span class="literal">NULL</span>) node-&gt;next-&gt;random = targetNode-&gt;next;</span><br><span class="line">        node = node-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    RandomListNode* newhead = pHead-&gt;next;</span><br><span class="line">    RandomListNode* newnode = newhead;</span><br><span class="line">    node = pHead;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// split the list</span></span><br><span class="line">        node-&gt;next = newnode-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (newnode-&gt;next != <span class="literal">NULL</span>) newnode-&gt;next = newnode-&gt;next-&gt;next;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">        newnode = newnode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> newhead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第二十五题"><a href="#第二十五题" class="headerlink" title="第二十五题"></a>第二十五题</h3><p>中序遍历即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode* pre = <span class="literal">NULL</span>;</span><br><span class="line">    TreeNode* head = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">Convert</span><span class="params">(TreeNode* pRootOfTree)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pRootOfTree == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        Convert(pRootOfTree-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (pre == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            pre = pRootOfTree;</span><br><span class="line">            head = pRootOfTree;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            pre-&gt;right = pRootOfTree;</span><br><span class="line">            pRootOfTree-&gt;left = pre;</span><br><span class="line">            pre = pRootOfTree;</span><br><span class="line">        &#125;</span><br><span class="line">        Convert(pRootOfTree-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="第二十六题"><a href="#第二十六题" class="headerlink" title="第二十六题"></a>第二十六题</h3><p>数组中大于一半的数。<br>方法一：储存一个数，如果不一样则相互抵消，如果一样则增加计数。最后验证该数次数是否超过一半。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> current = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (current == <span class="number">-1</span>) &#123;</span><br><span class="line">            current = numbers[i];</span><br><span class="line">            count ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (current != numbers[i]) &#123;</span><br><span class="line">                count --;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                count ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                current = numbers[i];</span><br><span class="line">                count ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (numbers[i] == current) &#123;</span><br><span class="line">            count ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (count &gt; numbers.size()/<span class="number">2</span>) <span class="keyword">return</span> current;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二：排序，选取中间的数。但是此法为O(nlogn)。复杂度较高。附quicksort代码。</p>
<h3 id="第二十七题"><a href="#第二十七题" class="headerlink" title="第二十七题"></a>第二十七题</h3><p>构建总数为K的最大heap。对每一个元素和heap比较，如果比堆顶小，则替换，重新排列heap。复杂度为O(nlogk)。<br>然而我用了暴力搜索，AC。大概是结果设置的太简单了。附k堆的代码。</p>
<h3 id="第二十八题"><a href="#第二十八题" class="headerlink" title="第二十八题"></a>第二十八题</h3><p>很简单的动态规划题。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> greatestSumForPosition = <span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> res = greatestSumForPosition;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="built_in">array</span>.size(); i++) &#123;</span><br><span class="line">        greatestSumForPosition = max(greatestSumForPosition + <span class="built_in">array</span>[i], <span class="built_in">array</span>[i]);</span><br><span class="line">        res = max(res, greatestSumForPosition);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第二十九题"><a href="#第二十九题" class="headerlink" title="第二十九题"></a>第二十九题</h3><p>归纳法，按照每一位来计算。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (tmp &lt;= n) &#123;</span><br><span class="line">        count += (n/(<span class="number">10</span>*tmp)) * tmp;</span><br><span class="line">        <span class="keyword">if</span> (n%(<span class="number">10</span>*tmp) &lt; tmp) &#123;</span><br><span class="line">            count += <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (n%(<span class="number">10</span>*tmp) &lt; <span class="number">2</span>*tmp) &#123;</span><br><span class="line">            count += n%(<span class="number">10</span>*tmp)-(tmp<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            count += tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp *= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第三十题"><a href="#第三十题" class="headerlink" title="第三十题"></a>第三十题</h3><p>简单来说就是对数的排序。即从最高位到最低位的排序。我贴上两种做法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gter</span> &#123;</span></span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="built_in">string</span> a, <span class="built_in">string</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> acount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> bcount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (acount &lt; a.size()<span class="number">-1</span> &amp;&amp; bcount &lt; b.size()<span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a.at(acount) != b.at(bcount)) <span class="keyword">return</span> a.at(acount) &gt; b.at(bcount);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (acount &lt; a.size()<span class="number">-1</span>) acount ++;</span><br><span class="line">                <span class="keyword">if</span> (bcount &lt; b.size()<span class="number">-1</span>) bcount ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  a.at(acount) &gt; b.at(bcount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">PrintMinNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; strings;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.size(); i++) &#123;</span><br><span class="line">            <span class="built_in">string</span> tmp = to_string(numbers[i]);</span><br><span class="line">            strings.push_back(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// sort(strings.begin(), strings.end(), gter());</span></span><br><span class="line">		sort(<span class="built_in">string</span>.begin(), strings.end(), gt);</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = strings.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            res.append(strings[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">gt</span><span class="params">(<span class="built_in">string</span> a, <span class="built_in">string</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> c = a + b;</span><br><span class="line">        <span class="built_in">string</span> d = b + a;</span><br><span class="line">        <span class="keyword">return</span> c &gt; d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="31-40"><a href="#31-40" class="headerlink" title="31 - 40"></a>31 - 40</h2><h3 id="第三十一题"><a href="#第三十一题" class="headerlink" title="第三十一题"></a>第三十一题</h3><p>丑数。很明显，后面的数要由前面数产生。那么如何产生呢？基本上这类题的做法都是维持一个数列，每一次push一个最小的候选人。难点在于确定候选人。<br>很明显，候选人=前人<em>2或者前人</em>3 或者前人<em>5。前人可以是数组中任意的数，那么复杂度为O(n^2)。<br>然而，稍加思考，便可以得知，有很多都不必要验证。比如上一次选择的是2</em>3，那么对于前人*3这个选项，2就可以被剔除掉。因此，只需要维持三个pointer即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetUglyNumber_Solution</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; uglyNumber;</span><br><span class="line">    <span class="keyword">int</span> base = <span class="number">1</span>;</span><br><span class="line">    uglyNumber.push_back(base);</span><br><span class="line">    <span class="keyword">int</span> ptr2=<span class="number">0</span>, ptr3=<span class="number">0</span>, ptr5=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (uglyNumber.size() &lt; index) &#123;</span><br><span class="line">        <span class="comment">// select the minimum of ptr2, 3, 5</span></span><br><span class="line">        uglyNumber.push_back(min(min(uglyNumber[ptr2]*<span class="number">2</span>, uglyNumber[ptr3]*<span class="number">3</span>), uglyNumber[ptr5]*<span class="number">5</span>));</span><br><span class="line">        <span class="keyword">if</span> (uglyNumber[ptr2]*<span class="number">2</span> == uglyNumber.back()) ptr2++;</span><br><span class="line">        <span class="keyword">if</span> (uglyNumber[ptr3]*<span class="number">3</span> == uglyNumber.back()) ptr3++;</span><br><span class="line">        <span class="keyword">if</span> (uglyNumber[ptr5]*<span class="number">5</span> == uglyNumber.back()) ptr5++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> uglyNumber.back();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第三十二题"><a href="#第三十二题" class="headerlink" title="第三十二题"></a>第三十二题</h3><p>找只出现一次的数。很明显是线性时间。使用bucket sort 来储存出现的个数（使用map也可以，不过map的开销更大）。</p>
<h3 id="第三十三题"><a href="#第三十三题" class="headerlink" title="第三十三题"></a>第三十三题</h3><p>很恐怖的一道题。算法还是比较简单的，用merge sort 的思想，在合并的时候从最后一个单位开始比较。一次比较可以增加size/2个逆序数组。<br>值得注意的是，在递归的时候一定要用引用！</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> cnt;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cp;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">InversePairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data)</span> </span>&#123;</span><br><span class="line">		cnt = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">// reverse(data.begin(), data.end());</span></span><br><span class="line">		cp = data;</span><br><span class="line">		mergeSort(data, <span class="number">0</span>, data.size());</span><br><span class="line">		<span class="keyword">return</span> cnt % <span class="number">1000000007</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; data, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (end - start &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">		mergeSort(data, start, mid);</span><br><span class="line">		mergeSort(data, mid, end);</span><br><span class="line">		<span class="keyword">int</span> ptr1 = mid - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> ptr2 = end - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> ptr = end - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (ptr1 &gt;= start &amp;&amp; ptr2 &gt;= mid) &#123;</span><br><span class="line">			<span class="keyword">if</span> (cp[ptr1] &gt; cp[ptr2]) &#123;</span><br><span class="line">				data[ptr--] = cp[ptr1--];</span><br><span class="line">				cnt += ptr2 - mid + <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				data[ptr--] = cp[ptr2--];</span><br><span class="line">			&#125;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="keyword">for</span> (;ptr1 &gt;= start;ptr1--) &#123;</span><br><span class="line">			data[ptr--] = cp[ptr1];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(;ptr2 &gt;= mid; ptr2--) &#123;</span><br><span class="line">			data[ptr--] = cp[ptr2];</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">            cp[i] = data[i];</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="第三十四题"><a href="#第三十四题" class="headerlink" title="第三十四题"></a>第三十四题</h3><p>本题比较简单。扫描得到长度，然后再扫描一次即可。</p>
<h3 id="第三十五题"><a href="#第三十五题" class="headerlink" title="第三十五题"></a>第三十五题</h3><p>binary search。</p>
<h3 id="第三十六题"><a href="#第三十六题" class="headerlink" title="第三十六题"></a>第三十六题</h3><p>两种做法，第一种递归。比较简单。第二种bfs，需要控制几个变量来记录第几层。</p>
<h3 id="第三十七题"><a href="#第三十七题" class="headerlink" title="第三十七题"></a>第三十七题</h3><p>方法一：直接递归，每一次求子树高度。但是balance要便利一遍，每个点都要求一次深度，所以复杂度为O(n^2).<br>方法二：直接求深度，如果左右子树不符合要求，直接返回false即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsBalanced_Solution</span><span class="params">(TreeNode* pRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> height(pRoot) != <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">height</span><span class="params">(TreeNode* pRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pRoot == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = height(pRoot-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = height(pRoot-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (right == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">abs</span>(left-right)&lt;=<span class="number">1</span>) ? max(left, right) + <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="第三十八题"><a href="#第三十八题" class="headerlink" title="第三十八题"></a>第三十八题</h3><p>方法一，直接用map。bucket sort的思想。扫描两次即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FindNumsAppearOnce</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data,<span class="keyword">int</span>* num1,<span class="keyword">int</span> *num2)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.size(); i++) &#123;</span><br><span class="line">        mp[data[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> firstNum = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mp[data[i]] == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (firstNum) &#123;</span><br><span class="line">                *num1 = data[i];</span><br><span class="line">                firstNum = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                *num2 = data[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二，利用xor，一定是奇数个数字的结果。同样是扫描两次，由于不用构建map，速度会快很多。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FindNumsAppearOnce</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data,<span class="keyword">int</span>* num1,<span class="keyword">int</span> *num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> bitResult = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.size(); i++) &#123;</span><br><span class="line">            bitResult ^= data[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// find the one position that is 1 in bitResult</span></span><br><span class="line">        *num1 = <span class="number">0</span>;</span><br><span class="line">        *num2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> index = findPos(bitResult);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isFirst(data[i], index)) &#123;</span><br><span class="line">                (*num1) ^= data[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                (*num2) ^= data[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findPos</span><span class="params">(<span class="keyword">int</span> bitResult)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((bitResult &amp; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp; index &lt; <span class="number">32</span>) &#123;</span><br><span class="line">            index ++;</span><br><span class="line">            bitResult &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isFirst</span><span class="params">(<span class="keyword">int</span> bitResult, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = bitResult &gt;&gt; index;</span><br><span class="line">        <span class="keyword">return</span> num&amp;<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="第三十九题"><a href="#第三十九题" class="headerlink" title="第三十九题"></a>第三十九题</h3><p>比较简单，求中间数字，要注意边界。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; FindContinuousSequence(<span class="keyword">int</span> sum) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; (sum/i) &gt;= (i/<span class="number">2</span>); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = sum / i;</span><br><span class="line">        <span class="keyword">if</span> (i%<span class="number">2</span>==<span class="number">0</span> &amp;&amp; ((sum%i)*<span class="number">2</span>==i) &amp;&amp; (sum/i)-(i/<span class="number">2</span>) + <span class="number">1</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = (sum/i)-(i/<span class="number">2</span>) + <span class="number">1</span>; j &lt; (sum/i)+(i/<span class="number">2</span>)+<span class="number">1</span>; j++) &#123;</span><br><span class="line">                v.push_back(j);</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i%<span class="number">2</span>==<span class="number">1</span> &amp;&amp; ((sum%i)==<span class="number">0</span>) &amp;&amp; (sum/i)-(i/<span class="number">2</span>)&gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = (sum/i)-(i/<span class="number">2</span>); j &lt; (sum/i)+(i/<span class="number">2</span>)+<span class="number">1</span>; j++) &#123;</span><br><span class="line">                v.push_back(j);</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(res.begin(), res.end());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第四十题"><a href="#第四十题" class="headerlink" title="第四十题"></a>第四十题</h3><p>维持两个指针，保证右端一定大于左端。从左到右扫描数组，对每一个数A，从右到左扫描数B。<br>线性时间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; FindNumbersWithSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">array</span>,<span class="keyword">int</span> sum) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">array</span>.size() == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = <span class="built_in">array</span>.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line">    <span class="keyword">for</span> (left = <span class="number">0</span>; left &lt; (right - left) / <span class="number">2</span> + <span class="number">1</span>; left++) &#123;</span><br><span class="line">        tmp = sum - <span class="built_in">array</span>[left];</span><br><span class="line">        <span class="keyword">if</span> (sum % <span class="built_in">array</span>[left] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="built_in">array</span>[right] &gt; tmp &amp;&amp; right &gt; left) &#123;</span><br><span class="line">                right --;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">array</span>[right] == tmp) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (left &lt; <span class="built_in">array</span>.size() &amp;&amp; right &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">array</span>[left] + <span class="built_in">array</span>[right] == sum) &#123;</span><br><span class="line">            res.push_back(<span class="built_in">array</span>[left]);</span><br><span class="line">            res.push_back(<span class="built_in">array</span>[right]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="41-50"><a href="#41-50" class="headerlink" title="41 - 50"></a>41 - 50</h2><h3 id="第四十一题"><a href="#第四十一题" class="headerlink" title="第四十一题"></a>第四十一题</h3><p>简单的做法就是用辅助数组，然后线性扫描即可。<br>但是上述做法需要额外的空间，还有一种不需要空间的做法。YX = (XT YT)T<br>即对前后分别做反转，然后对全部做反转。需要扫描三次，但是不需要空间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">LeftRotateString</span><span class="params">(<span class="built_in">string</span> str, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// YX = (XT YT)T</span></span><br><span class="line">    <span class="keyword">int</span> size = str.size();</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    n = n % size;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = n - <span class="number">1</span>; i &lt; j; i++, j--) swap(str[i], str[j]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n, j = size - <span class="number">1</span>; i &lt; j; i++, j--) swap(str[i], str[j]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = size - <span class="number">1</span>; i &lt; j; i++, j--) swap(str[i], str[j]);</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第四十二题"><a href="#第四十二题" class="headerlink" title="第四十二题"></a>第四十二题</h3><p>注意系数即可完成。比较简单。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">ReverseSentence</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> size = str.size();</span><br><span class="line">	<span class="keyword">if</span> (size == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">	<span class="function"><span class="built_in">string</span> <span class="title">res</span><span class="params">(str)</span></span>;</span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">		<span class="comment">// scan from last to front</span></span><br><span class="line">		<span class="keyword">if</span> (str[i] == <span class="string">' '</span>) &#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			<span class="comment">// copy to last pos</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; str[j] != <span class="string">' '</span> &amp;&amp; j &lt; size; j++) res[count++] = str[j];</span><br><span class="line">			res[count++] = <span class="string">' '</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (str[i] == <span class="string">' '</span>) <span class="keyword">break</span>;</span><br><span class="line">		res[count++] = str[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第四十三题"><a href="#第四十三题" class="headerlink" title="第四十三题"></a>第四十三题</h3><p>比较简单。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsContinuous</span><span class="params">( <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = numbers.size();</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    sort(numbers.begin(), numbers.end());</span><br><span class="line">    <span class="keyword">int</span> godnum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (numbers[i] == <span class="number">0</span>) godnum++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = max(<span class="number">1</span>, i+<span class="number">1</span>); j &lt; size; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (numbers[j] == numbers[j<span class="number">-1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        count += (numbers[j] - numbers[j<span class="number">-1</span>] - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count &lt;= godnum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第四十四题"><a href="#第四十四题" class="headerlink" title="第四十四题"></a>第四十四题</h3><p>简单做法当然是模拟。构建数组然后循环。但是这种题明显是可以从公式中推出来的。<br>约瑟夫环${f(n,m)=(f(n-1,m)+m)%n}$<br>由此可以写出递归代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> (m%n+LastRemaining_Solution(n<span class="number">-1</span>, m))%n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第四十五题"><a href="#第四十五题" class="headerlink" title="第四十五题"></a>第四十五题</h3><p>卡了半个小时，看了各位大佬的做法，心态有点小崩。任重而道远啊。<br>方法一：使用sizeof模拟乘法，使用位数移动模拟除法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Sum_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> a[n][n+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="keyword">sizeof</span>(a) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二：使用&amp;&amp;短路的特性模拟if</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Sum_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = n;</span><br><span class="line">    <span class="keyword">int</span> ans = (n &gt; <span class="number">0</span>) &amp;&amp; (sum += Sum_Solution(n<span class="number">-1</span>));</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第四十六题"><a href="#第四十六题" class="headerlink" title="第四十六题"></a>第四十六题</h3><p>很明显是要从bit位来作。<br>二进制加法，如果xor结果为1，则不进位。结果相应位应为1.<br>如果and结果为1，则需要进位，结果高一位应为1.<br>那么如何把这两个结合到一起呢？用一个循环直到xor等于0就好了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (num2) &#123;</span><br><span class="line">        <span class="keyword">int</span> xort = num1 ^ num2;</span><br><span class="line">        num2 = (num1 &amp; num2) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        num1 = xort;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第四十七题"><a href="#第四十七题" class="headerlink" title="第四十七题"></a>第四十七题</h3><p>每一位来转换。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StrToInt</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// check if the input is valid</span></span><br><span class="line">	<span class="keyword">int</span> ch = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> startPos = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (str[<span class="number">0</span>] == <span class="string">'+'</span>) &#123;</span><br><span class="line">		ch = <span class="number">1</span>;</span><br><span class="line">		startPos = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (str[<span class="number">0</span>] == <span class="string">'-'</span>) &#123;</span><br><span class="line">		ch = <span class="number">-1</span>;</span><br><span class="line">		startPos = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = startPos; i &lt; str.size(); i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!(str[i] &gt;= <span class="string">'0'</span> &amp;&amp; str[i] &lt;= <span class="string">'9'</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = startPos; i &lt; str.size(); i++) &#123;</span><br><span class="line">		res *= <span class="number">10</span>;</span><br><span class="line">		res += (str[i] - <span class="string">'0'</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res * ch;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第四十八题"><a href="#第四十八题" class="headerlink" title="第四十八题"></a>第四十八题</h3><p>bucket sort的思想。如果已经有数，返回。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[], <span class="keyword">int</span> length, <span class="keyword">int</span>* duplication)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (numbers[numbers[i]] == numbers[i] &amp;&amp; numbers[i] != i) &#123;</span><br><span class="line">            *duplication = numbers[i];</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = numbers[numbers[i]];</span><br><span class="line">            numbers[numbers[i]] = numbers[i];</span><br><span class="line">            numbers[i] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第四十九题"><a href="#第四十九题" class="headerlink" title="第四十九题"></a>第四十九题</h3><p>很有趣的一道题。要用reuse的思想。如何reuse之前的结果呢？以下图说明了做法。<br><img src="49.jpg" alt></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; multiply(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; B;</span><br><span class="line">    B.push_back(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; A.size(); i++) &#123;</span><br><span class="line">        B.push_back(B.back()*A[i<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    C.push_back(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = A.size() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        C.push_back(C.back()*A[i+<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size(); i++) &#123;</span><br><span class="line">        B[i] *= C[A.size() - i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> B;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第五十题"><a href="#第五十题" class="headerlink" title="第五十题"></a>第五十题</h3><p>正则表达式，递归来做。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">match</span><span class="params">(<span class="keyword">char</span>* str, <span class="keyword">char</span>* pattern)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="string">" "</span> &lt;&lt; pattern;</span><br><span class="line">	<span class="keyword">if</span> (str[<span class="number">0</span>] == <span class="number">0</span> &amp;&amp; pattern[<span class="number">0</span>] == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">if</span> (pattern[<span class="number">0</span>] &amp;&amp; pattern[<span class="number">1</span>] == <span class="string">'*'</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (match(str, pattern + <span class="number">2</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (str[<span class="number">0</span>] &amp;&amp; (str[<span class="number">0</span>] == pattern[<span class="number">0</span>] || pattern[<span class="number">0</span>] == <span class="string">'.'</span>)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (match(str + <span class="number">1</span>, pattern + <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">if</span> (pattern[<span class="number">1</span>] == <span class="string">'*'</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (match(str + <span class="number">1</span>, pattern)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第五十一题"><a href="#第五十一题" class="headerlink" title="第五十一题"></a>第五十一题</h3><p>注意细节。分几个case<br>case1. integer（+/- [1-9][0-9]* or 0)<br>case2. float (+/- [0-9]<em>.[0-9]</em>)
case3. e (float E integer)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isInteger</span><span class="params">(<span class="keyword">char</span>* <span class="built_in">string</span>, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> startPos = start;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">string</span>[startPos] == <span class="string">'+'</span> || <span class="built_in">string</span>[startPos] == <span class="string">'-'</span>) startPos += <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">string</span>[startPos] &gt;= <span class="string">'1'</span> &amp;&amp; <span class="built_in">string</span>[startPos] &lt;= <span class="string">'9'</span>) &#123;</span><br><span class="line">		<span class="keyword">bool</span> pureNumber = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = startPos + <span class="number">1</span>; i &lt; end; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!(<span class="built_in">string</span>[i] &gt;= <span class="string">'0'</span> &amp;&amp; <span class="built_in">string</span>[i] &lt;= <span class="string">'9'</span>)) &#123;</span><br><span class="line">				pureNumber = <span class="literal">false</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (pureNumber) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">string</span>[startPos] == <span class="string">'0'</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (startPos + <span class="number">1</span> == end) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isNumber</span><span class="params">(<span class="keyword">char</span>* <span class="built_in">string</span>, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!(<span class="built_in">string</span>[i] &gt;= <span class="string">'0'</span> &amp;&amp; <span class="built_in">string</span>[i] &lt;= <span class="string">'9'</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isFloat</span><span class="params">(<span class="keyword">char</span>* <span class="built_in">string</span>, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> startPos = start;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">string</span>[startPos] == <span class="string">'+'</span> || <span class="built_in">string</span>[startPos] == <span class="string">'-'</span>) startPos = startPos + <span class="number">1</span>;</span><br><span class="line">	<span class="comment">// scan for point</span></span><br><span class="line">	<span class="keyword">int</span> pos = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = startPos; i &lt; end; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">string</span>[i] == <span class="string">'.'</span>) &#123;</span><br><span class="line">			pos = i;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (pos != <span class="number">-1</span> &amp;&amp; (isInteger(<span class="built_in">string</span>, start, pos) || pos == startPos) &amp;&amp; isNumber(<span class="built_in">string</span>, pos + <span class="number">1</span>, end)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isNumeric</span><span class="params">(<span class="keyword">char</span>* <span class="built_in">string</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> size = <span class="built_in">strlen</span>(<span class="built_in">string</span>);</span><br><span class="line">	<span class="keyword">if</span> (size &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (isInteger(<span class="built_in">string</span>, <span class="number">0</span>, size)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">if</span> (isFloat(<span class="built_in">string</span>, <span class="number">0</span>, size)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// scan for 'e' 'E'</span></span><br><span class="line">	<span class="keyword">int</span> pos = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">string</span>[i] == <span class="string">'e'</span> || <span class="built_in">string</span>[i] == <span class="string">'E'</span>) &#123;</span><br><span class="line">			pos = i;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (pos != <span class="number">-1</span> &amp;&amp; (isFloat(<span class="built_in">string</span>, <span class="number">0</span>, pos) || isInteger(<span class="built_in">string</span>, <span class="number">0</span>, pos)) &amp;&amp; isInteger(<span class="built_in">string</span>, pos + <span class="number">1</span>, size)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第五十二题<br>比较简单。因为给定的是char，所以用bucket sort计数即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">  <span class="comment">//Insert one char from stringstream</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> ch)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (cnt[ch] == <span class="number">0</span>)</span><br><span class="line">			str.push_back(ch);</span><br><span class="line">        cnt[ch] ++;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//return the first appearence once char in current stringstream</span></span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">FirstAppearingOnce</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (ptr &lt; str.size() &amp;&amp; cnt[str[ptr]] != <span class="number">1</span>) &#123;</span><br><span class="line">            ptr++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (str.size() == ptr) <span class="keyword">return</span> <span class="string">'#'</span>;</span><br><span class="line">        <span class="keyword">return</span> str[ptr];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; str;</span><br><span class="line">    <span class="keyword">char</span> cnt[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">int</span> ptr=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>第五十三题<br>三个方法。<br>方法一，直接keep住过往的node，然后对每一node检查是否访问过。O(n^2).</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isVisited</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; v, ListNode* node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v[i] == node) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ListNode* <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode* pHead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;ListNode*&gt; visited;</span><br><span class="line">    ListNode* node = pHead;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">NULL</span> &amp;&amp; !isVisited(visited, node)) &#123;</span><br><span class="line">        visited.push_back(node);</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二，每次访问之后，把前面的链接断掉。这样如果出现loop，则下一次访问时，next为null(ps: 不过这样会破坏原有的list). O(n)<br>方法三，先求出ring的长度a，然后让指针一先走a，指针b再走。则ab相遇时，一定在入口点。O(n)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode* pHead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// get the length of loop</span></span><br><span class="line">    <span class="comment">// Vptr1 = 2, Vptr2 = 1</span></span><br><span class="line">    <span class="keyword">if</span> (pHead == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (pHead-&gt;next == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (pHead-&gt;next-&gt;next == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    ListNode* ptr1 = pHead-&gt;next-&gt;next;</span><br><span class="line">    ListNode* ptr2 = pHead-&gt;next;</span><br><span class="line">    <span class="keyword">int</span> time = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (ptr1 != ptr2 &amp;&amp; ptr1 != <span class="literal">NULL</span> &amp;&amp; ptr2 != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ptr1 = ptr1-&gt;next;</span><br><span class="line">        ptr2 = ptr2-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (ptr1 != <span class="literal">NULL</span>) ptr1 = ptr1-&gt;next;</span><br><span class="line">        time += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ptr1 == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> lengthOfLoop = time;</span><br><span class="line">    ptr1 = pHead;</span><br><span class="line">    ptr2 = pHead;</span><br><span class="line">    <span class="comment">// move ptr1 to length of loop</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lengthOfLoop; i++) &#123;</span><br><span class="line">        ptr1 = ptr1-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (ptr1 != ptr2) &#123;</span><br><span class="line">        ptr1 = ptr1-&gt;next;</span><br><span class="line">        ptr2 = ptr2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ptr1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第五十四题<br>暖心题。比较简单。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">deleteDuplication</span><span class="params">(ListNode* pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pHead == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (pHead-&gt;next == <span class="literal">NULL</span>) <span class="keyword">return</span> pHead;</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span> (pHead != <span class="literal">NULL</span> &amp;&amp; pHead-&gt;val == pHead-&gt;next-&gt;val || (pHead-&gt;val == tmp)) &#123;</span><br><span class="line">            tmp = pHead-&gt;val;</span><br><span class="line">            pHead = pHead-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (pHead-&gt;next == <span class="literal">NULL</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pHead == <span class="literal">NULL</span> || pHead-&gt;val == tmp) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (pHead-&gt;next == <span class="literal">NULL</span>) <span class="keyword">return</span> pHead;</span><br><span class="line">        ListNode* node = pHead-&gt;next-&gt;next;</span><br><span class="line">        ListNode* pre = pHead;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node != <span class="literal">NULL</span> &amp;&amp; node-&gt;val == pre-&gt;next-&gt;val) &#123;</span><br><span class="line">                <span class="keyword">while</span> (node != <span class="literal">NULL</span> &amp;&amp; node-&gt;val == pre-&gt;next-&gt;val) &#123;</span><br><span class="line">                    node = node-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                pre-&gt;next = node;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> pre = pre-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (node != <span class="literal">NULL</span>) node = node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pHead;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>第五十五题<br>分类讨论，共有三种case，node是左子，右子，家长。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeLinkNode* <span class="title">GetNext</span><span class="params">(TreeLinkNode* pNode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pNode == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// case1 if node is leftchild</span></span><br><span class="line">    TreeLinkNode* parent = pNode-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (parent != <span class="literal">NULL</span> &amp;&amp; parent-&gt;left == pNode) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pNode-&gt;right == <span class="literal">NULL</span>) <span class="keyword">return</span> pNode-&gt;next;</span><br><span class="line">        TreeLinkNode* node = pNode-&gt;right;</span><br><span class="line">        <span class="keyword">while</span> (node-&gt;left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            node = node-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// case2 if node is rightchild</span></span><br><span class="line">    <span class="keyword">if</span>(parent != <span class="literal">NULL</span> &amp;&amp; parent-&gt;right == pNode) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pNode-&gt;right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            TreeLinkNode* node = pNode-&gt;right;</span><br><span class="line">            <span class="keyword">while</span> (node-&gt;left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                node = node-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeLinkNode* grandpa = parent-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (grandpa == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (grandpa-&gt;left == parent) <span class="keyword">return</span> grandpa;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// case3 if node has no parent</span></span><br><span class="line">    <span class="keyword">if</span> (parent == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pNode-&gt;right == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        TreeLinkNode* node = pNode-&gt;right;</span><br><span class="line">        <span class="keyword">while</span> (node-&gt;left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            node = node-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第五十六题<br>使用递归可以轻松解决。方法一，构建镜像，再比较是否相等。方法二，直接比较两个节点的左右是否对称。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mirror</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">NULL</span>) <span class="keyword">return</span> node;</span><br><span class="line">		TreeNode* n = <span class="keyword">new</span> TreeNode(node-&gt;val);</span><br><span class="line">		TreeNode* left = <span class="literal">NULL</span>;</span><br><span class="line">		TreeNode* right = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">if</span> (node-&gt;left != <span class="literal">NULL</span>) n-&gt;right = mirror(node-&gt;left);</span><br><span class="line">		<span class="keyword">if</span> (node-&gt;right != <span class="literal">NULL</span>) n-&gt;left = mirror(node-&gt;right);</span><br><span class="line">		<span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSame</span><span class="params">(TreeNode* root, TreeNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span> &amp;&amp; node == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root != <span class="literal">NULL</span> &amp;&amp; node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;val != node-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (isSame(root-&gt;left, node-&gt;left) &amp;&amp; isSame(root-&gt;right, node-&gt;right)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode* pRoot)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// build mirror</span></span><br><span class="line">        TreeNode* m = mirror(pRoot);</span><br><span class="line">        <span class="comment">// check if mirror is same with pRoot</span></span><br><span class="line">        <span class="keyword">return</span> isSame(pRoot, m);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>第五十七题<br>BFS即可。值得注意的是，如果要在bfs得到层数，需要改变queue的pop时机，每一次都pop一层。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; Print(TreeNode* pRoot) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">if</span> (pRoot == <span class="literal">NULL</span>) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="comment">// bfs</span></span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">    q.push(pRoot);</span><br><span class="line">    <span class="keyword">bool</span> odd = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        <span class="comment">// pop all node out of queue</span></span><br><span class="line">        <span class="keyword">int</span> size = q.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            TreeNode* node = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            tmp.push_back(node-&gt;val);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left != <span class="literal">NULL</span>) q.push(node-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right != <span class="literal">NULL</span>) q.push(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!odd) &#123;</span><br><span class="line">            reverse(tmp.begin(), tmp.end());</span><br><span class="line">        &#125;</span><br><span class="line">        res.push_back(tmp);</span><br><span class="line">        odd = !odd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第五十八题<br>同上一题一样。</p>
<p>第五十九题<br>用dfs可以完成。值得注意的是，妥善使用c++中的引用可以很elegant的完成任务。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Serialize</span><span class="params">(TreeNode* root, <span class="built_in">string</span>&amp; str)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			str += <span class="string">"#"</span>;</span><br><span class="line">			str += <span class="string">","</span>;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		str += to_string(root-&gt;val);</span><br><span class="line">		str += <span class="string">","</span>;</span><br><span class="line">		Serialize(root-&gt;left, str);</span><br><span class="line">		Serialize(root-&gt;right, str);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">char</span>* <span class="title">Serialize</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">		<span class="built_in">string</span> str;</span><br><span class="line">		Serialize(root, str);</span><br><span class="line">		<span class="keyword">char</span>* res = <span class="keyword">new</span> <span class="keyword">char</span>[str.length()];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">			res[i] = str[i];</span><br><span class="line">		&#125;</span><br><span class="line">		res[str.length()<span class="number">-1</span>] = <span class="string">'\0'</span>;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>* ptr)</span> </span>&#123;</span><br><span class="line">        ++index;</span><br><span class="line">		<span class="keyword">if</span> (ptr[index] == <span class="string">'#'</span>) &#123;</span><br><span class="line">			++index;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="keyword">int</span> num = ptr[index++] - <span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">for</span> (; ptr[index] != <span class="string">','</span> &amp;&amp; ptr[index] != <span class="string">'#'</span>; index++) &#123;</span><br><span class="line">            num = <span class="number">10</span> * num + ptr[index] - <span class="string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* node = <span class="keyword">new</span> TreeNode(num);</span><br><span class="line">        node-&gt;left = dfs(ptr);</span><br><span class="line">        node-&gt;right = dfs(ptr);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">Deserialize</span><span class="params">(<span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line">        TreeNode* node = dfs(str);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">-1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>第六十题<br>使用dfs遍历即可。O(klogn)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left != <span class="literal">NULL</span> &amp;&amp; res == <span class="literal">NULL</span>) DFS(node-&gt;left);</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span> (count == target) res = node;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right != <span class="literal">NULL</span> &amp;&amp; res == <span class="literal">NULL</span>) DFS(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">KthNode</span><span class="params">(TreeNode* pRoot, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        target = k;</span><br><span class="line">        DFS(pRoot);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> target = <span class="number">0</span>;</span><br><span class="line">    TreeNode* res = <span class="literal">NULL</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/26/career-plan/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李书赫">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404 Not Found">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/26/career-plan/" itemprop="url">校招准备</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-26T16:26:32+08:00">
                2019-06-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Checklist:</p>
<ul>
<li><input checked disabled type="checkbox"> 英文简历</li>
<li><input disabled type="checkbox"> 中文简历</li>
<li><input disabled type="checkbox"> 剑指offer (C/C++)</li>
<li><input disabled type="checkbox"> 暑期实习</li>
<li><input disabled type="checkbox"> 扫雷</li>
<li><input disabled type="checkbox"> 扫雷AI</li>
<li><input disabled type="checkbox"> Search Engine</li>
<li><input disabled type="checkbox"> C++ 基础知识巩固</li>
<li><input disabled type="checkbox"> JAVA 基础知识巩固</li>
<li><input disabled type="checkbox"> Python 基础知识巩固</li>
<li><input disabled type="checkbox"> 算法基础知识巩固</li>
<li><input disabled type="checkbox"> 阅读深入了解计算机系统</li>
<li><input disabled type="checkbox"> C++ primer</li>
<li><input disabled type="checkbox"> 数据库</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/26/Hello-World-0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李书赫">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404 Not Found">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/26/Hello-World-0/" itemprop="url">Hello World</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-26T14:12:21+08:00">
                2019-06-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Hello World</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="李书赫">
            
              <p class="site-author-name" itemprop="name">李书赫</p>
              <p class="site-description motion-element" itemprop="description">It works on my machine</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">李书赫</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  


  

  

</body>
</html>
