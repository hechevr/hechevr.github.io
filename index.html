<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="It works on my machine">
<meta property="og:type" content="website">
<meta property="og:title" content="404 Not Found">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="404 Not Found">
<meta property="og:description" content="It works on my machine">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="404 Not Found">
<meta name="twitter:description" content="It works on my machine">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>404 Not Found</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">404 Not Found</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/24/computer_system_conclusion/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李书赫">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404 Not Found">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/24/computer_system_conclusion/" itemprop="url">计算机系统总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-24T23:22:43+08:00">
                2019-07-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>抽空把深入了解计算机系统简要看了一遍。这里做个小总结。</p>
<h3 id="计算机系统的基本特性"><a href="#计算机系统的基本特性" class="headerlink" title="计算机系统的基本特性"></a>计算机系统的基本特性</h3><p>并发，共享，虚拟，异步。<br>并发指在计算机系统中同一时间段内共同运行着多个程序。（区别并行）具体包括用户程序与用户程序，用户程序与系统程序。<br>共享指操作系统程序和多个用户程序共享系统资源（包括cpu运行时间，内存分配）。<br>虚拟（主要指Virtual Memory）指通过技术使得物理实体对应虚拟逻辑对象。如虚拟内存将物理内存对应到程序享用的虚拟地址，这样每个进程都仿佛独占内存。<br>异步。同步异步是一个重要的区分特性。同步指几个进程指令需要有先后的执行，如操作一必须在操作二完成后开始执行。而异步指的是进程以不可预知的速度向前推进。每个进程何时执行，合适暂停，以何样的速度推进都是不可预知的。（好像和我理解的异步有点不一样）</p>
<h3 id="操作系统的主要功能"><a href="#操作系统的主要功能" class="headerlink" title="操作系统的主要功能"></a>操作系统的主要功能</h3><p>进程控制，进程同步，进程通信，调度。<br>临界资源：一次只能宫一个进程访问的资源。临界区：访问临界区的程序。当一个进程进入临界区时，其他进程无法进入临界区。<br>对临界区加锁可以实现互斥。mutex和semphore都可以充当锁子。<br>进程同步指的是在异步环境下一组并发进程通过相互发送消息进行互相合作，互相等待，使得各自进程按照一定速度执行的过程。<br>进程通信：进程间通信有五种方式，分别是pipe，FIFO，signal，semaphore，共享内存。<br>pipe：单向，有亲缘，只存在于内存中（通过read，write读写）。<br>FIFO：命名管道，无关进程也可以交换数据。以文件形式存在文件系统中。<br>signal：消息链接表，存放在内核中。根据优先级来确定先后，独立于发送接收进程（进程终止，队列仍旧存在），可以实现随机查询，无关次序。<br>semaphore：计数器。P：wait until &gt; 0，semaphore-=1；V：semaphore+=1。用于进程同步，原子操作（即只存在执行或不执行，没有中间状态）。<br>共享内存：最快的通信方式。在内存中开辟一块供多个进程操作。需要配合semaphore。<br>操作系统的任务调度：FIFO(FCFS)，SJF(Shortest job first)，Round Robin，多层反馈队列，高响应比优先调度。<br>Round Robin：每个就绪进程获得一小段CPU时间，时间段用完后，进程交出cpu，重新回到就绪队列，等待下一次分配。<br>多层反馈队列：将任务分配到不同优先级的队列中。有以下几个规则。</p>
<ol>
<li>开始时所有任务都是最高优先级。2. 如果任务在规定时间片中没有执行完毕（没有block）则将他下放到下一个优先级。3.每隔一段时间，重新分配优先级（即将所有任务放到最高级中）。<br>高响应比优先调度。对每一个就绪进程计算相应比，执行最高的那个。相应比=（等待时间+执行时间）/执行时间</li>
</ol>
<h3 id="线程与进程"><a href="#线程与进程" class="headerlink" title="线程与进程"></a>线程与进程</h3><p>进程是系统分配资源和调度的基本单位。当一个程序要执行时，系统会建立进程并为其分配资源。<br>线程是进程的一个实体。一个进程可以有一个或多个线程。线程自己不拥有资源，但是可以对进程的资源进行操作。<br>线程之间可以共享的部分：数据段，代码段，堆，File Descriptor（文件描述表）。线程之间不可以共享的部分：stack，program counter，register state。<br>线程与进程的区别：进程是一个具有独立功能的活动，进程之间相互独立，通信需要通过核来完成。线程本省不具备资源，他是系统计算统筹的单位。进程有独立的地址空间，一段崩溃后，不会影响其他进程。线程则没有独立的地址空间，一旦线程出现了问题，则整个进程都都会崩溃。进程切换时要比线程消耗大。</p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>死锁指在多个并发（很重要）进程中，如果每个进程持有某种资源而又等待别的进程释放资源，并且维持这种状态都不能推进的一种状态。<br>条件：1. 互斥。一个资源只能被一个进程使用。2. 不可抢占。进程不能从别人手中抢占资源。3. 不释放。进程在自己等待状态不释放已有资源。4. 进程与资源形成闭合环路状态。<br>银行家算法：每一个进程进入系统时，先声明自己可能需要的资源总量。系统在选择执行某一个任务前，先检查该任务是否安全。即假如满足所选任务的需求，是否还有足够的资源满足剩下资源需求最大的进程的请求。如果安全，则分配执行，否则，该进程会被阻塞。<br>银行家算法是一种预防死锁的方法，而并非打破死锁的方法。打破死锁需要破坏其四条条件之一。1. 强制资源可以共享。2. 进程可以抢占已被占有的资源。3. 进程在阻塞情况下释放自己经占有的资源。4. 检查是否闭合环路。</p>
<h3 id="连续分配方式"><a href="#连续分配方式" class="headerlink" title="连续分配方式"></a>连续分配方式</h3><p>为一个用户程序分配一个连续的内存空间。可以分为单一连续分配，固定分区分配，动态分区分配，动态重定位分区分配。<br>单一连续分配：将内存分为系统区（内存低端）和高地址（内存高端）。静态分配（作业一旦进入，等待运行结束才可以释放内存）。适用于单用户单任务的os。<br>固定分区分配：内存空间划分为若干个固定大小的分区。一个作业装入一个分区。<br>动态分区分配：在作业进入内存时，根据作业大小动态的建立分区。1. 基于顺序搜索的动态分区分配算法。2. 基于索引搜索的动态分区分配算法。<br>动态重定位分区分配：同动态分区分配基本一致，增加了“紧凑”。如果没有单一连续空间满足需求，则将其他任务所使用的空间堆积在一起。</p>
<h3 id="虚拟储存器"><a href="#虚拟储存器" class="headerlink" title="虚拟储存器"></a>虚拟储存器</h3><p>在主存中只保存活动区域，其余所需数据放在disk（磁盘）中。<br>从程序角度来看，程序可以申请超过内存本身大小的空间。所申请的虚拟页，存放在内存和硬盘中。<br>虚拟页可以分为已缓存（在内存中），为缓存（在disk中），未分配（没有数据与其关联）。<br>程序访问为缓存和未分配状态的page都会造成缺页中断。<br>缺页中断在实际操作中的表现为程序访问某一虚拟地址，其对应的page table validation bit为0.<br>产生缺页中断后，会采用LRU（least recently used）算法挑选一个牺牲页面同disk中的请求页置换。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/13/reactor-nodejs/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李书赫">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404 Not Found">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/13/reactor-nodejs/" itemprop="url">reactor模型和nodejs的实现</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-13T10:47:03+08:00">
                2019-07-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="reactor"><a href="#reactor" class="headerlink" title="reactor"></a>reactor</h2><h3 id="同步，异步，阻塞，非阻塞"><a href="#同步，异步，阻塞，非阻塞" class="headerlink" title="同步，异步，阻塞，非阻塞"></a>同步，异步，阻塞，非阻塞</h3><p>Synchronous IO: operatins causes the requesting process to be blocked until that io operation completes.<br>Asychronrous IO: operations that does not cause the requesting process to be blocked.<br>阻塞：程序会自己挂起等待结果。<br>非阻塞：如果数据没有准备好，程序不关系结果直接返回。需要程序自己回去检查数据是否就绪。</p>
<p>简单来讲，同步针对的是程序和kernel的通信。如果一个操作会返回结果（数据准备好或者没准备好），那么这个call就是同步的。反之，如果一个call不返回结果（我不知道数据怎么样，需要kernel自己回调函数），那么这个call就是异步的。<br>所以，同步可以阻塞也可以非阻塞，看程序本身如何应对返回结果（是直接从kernel拷贝数据还是先返回）。<br>异步只能非阻塞（因为异步表示kernel会将所有东西准备好然后回调函数，所以不存在call需要等待的情况）。</p>
<p>如果一个call需要自己去查询数据是否就绪，则一定为同步（epoll很tricky，虽然运用了callback，但仍旧需要epoll_wait去检查，所以是同步的）<br>select/poll/epoll都是同步。<br>如果epoll_wait(timeout)timeout=-1，阻塞（知道捕获到信号）。timeout=0，非阻塞，直接返回。timeout&gt;0阻塞n毫秒。</p>
<p>总结，IO call分为两步</p>
<ol>
<li>询问数据是否就绪。</li>
<li>将数据从kernal拷贝到进程。<br>同步异步针对两个步骤，任何一个阻塞，都为同步。<br>阻塞非阻塞针对步骤1，步骤二不理会。</li>
</ol>
<h3 id="reactor的特点"><a href="#reactor的特点" class="headerlink" title="reactor的特点"></a>reactor的特点</h3><ol>
<li>事件驱动</li>
<li>处理多个输入源</li>
<li>通过service handler同步的将输入事件（event）采用多路复用（select/poll/epoll）分发给相应的request handler同步的将输入事件（event）采用多路复用（select/poll/epoll）分发给相应的request handler处理。</li>
</ol>
<p>单线程reactor：一个线程来处理连接，读写，计算。消息的处理被放到独立的handler中。<br><img src="reactor_single.png" alt></p>
<p><img src="reactor_multi.png" alt><br>多线程reactor：为handler开启不同的县城。</p>
<p><img src="reactor.png" alt><br>主从reactor模型：main reactor针对连接，subreactor针对io操作。</p>
<h2 id="nodejs"><a href="#nodejs" class="headerlink" title="nodejs"></a>nodejs</h2><p><img src="nodejs_framework.png" alt><br>由上图可知，nodejs包括顶层的javascript（程序员层面）和底层的V8, libuv（底层io实现）。<br>JS层面，程序是同步阻塞单线程的。如果语句出现问题，则整个程序卡住。<br>事件循环函数会不断检查事件队列中有没有需要处理的时间，直到程序结束。此循环对开发者不可见，由libuv实现。<br>libuv是一个底层的用c实现的异步io库。通过主线程检查事件队列，线程池来处理不同handler。</p>
<p>nodejs编写简单，处理并发时有独特的优势。然而，当某需求需要在js上大量的cpu计算时，单线程的劣势就体现出来了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/09/Select-poll-epoll/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李书赫">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404 Not Found">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/09/Select-poll-epoll/" itemprop="url">Select_poll_epoll</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-09T00:09:55+08:00">
                2019-07-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h3><p><img src="select.png" alt></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, fd_set* readfds, fd_set* writefds, fd_set* exceptfds, struct timeval* timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<p>监控三组descriptor。并且block进程，如果有descriptor数据就绪，则返回。<br>使用时需要遍历descriptor list。<br>缺点：</p>
<ol>
<li>每次调用select，需要把fd集合从用户空间拷贝到kernel，开销会随着fd增多而增大。</li>
<li>调用select都需要在内核便利传递来的所有fd，开销会随着fd增多增大。</li>
<li>支持文件描述符数量较小。</li>
</ol>
<h3 id="Poll"><a href="#Poll" class="headerlink" title="Poll"></a>Poll</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd* fds, <span class="keyword">nfds_t</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<p>相对于select的优点：</p>
<ol>
<li>集合了所有descriptor。</li>
<li>没有文件描述符数量的限制。<br>缺点：在fds很大时效率很低。和select没有本质区别。</li>
</ol>
<h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event* events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event* event)</span></span>;</span><br></pre></td></tr></table></figure>

<p>每次注册新事件时，会把所有的fd拷贝进内核，因此，每个fd在整个过程中会被拷贝一次。<br>在epoll_ctl时会把current遍历一遍，为每一个fd制定回调函数。当设备就绪时，回调函数会被call（把就绪的fd加入就绪链表）。<br>epoll_wait的工作是查看就绪链表，因此不需要每次新设备出现时都便利fd。</p>
<p>mmap：内存映射文件。文件磁盘地址和进程虚拟地址空间中一段虚拟地址一一对应。内核空间对文件的修改直接反应用户空间，可以实现不同进程间的文件共享。<br>epoll就用了mmap，所以速度会快一些。</p>
<p><img src="select_poll_epoll.png" alt></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/03/project/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李书赫">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404 Not Found">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/03/project/" itemprop="url">project</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-03T21:25:37+08:00">
                2019-07-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/玩具/" itemprop="url" rel="index">
                    <span itemprop="name">玩具</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>一时兴起决定写写爬虫来当学生项目。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">url = <span class="string">"http://www.qiushibaike.com/"</span></span><br><span class="line">tag = <span class="string">"hot/page/1"</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">'User-Agent'</span>: <span class="string">'User-Agent:Mozilla/5.0'</span></span><br><span class="line">&#125;</span><br><span class="line">request = urllib.request.Request(url+tag, headers=headers)</span><br><span class="line">response = urllib.request.urlopen(request)</span><br><span class="line">content = response.read()</span><br><span class="line">content_utf8 = content.decode(<span class="string">'utf-8'</span>)</span><br><span class="line"></span><br><span class="line">restr = <span class="string">'&lt;div class="article.*?&lt;div class="author.*?&lt;h2&gt;(.*?)&lt;/h2&gt;.*?&lt;/div&gt;.*?href="/article/(.*?)".*?&lt;span&gt;(.*?)&lt;/span&gt;.*?&lt;/div&gt;'</span></span><br><span class="line">pattern = re.compile(restr, re.S)</span><br><span class="line">items = re.findall(pattern, content_utf8)</span><br><span class="line">write_html(content)</span><br></pre></td></tr></table></figure>

<p>扒了糗事百科首页上的作者，链接。<br>目前打算是写一个自动爬段子分类推送的系统。然而发现现在的网站都坏坏，一个个的都不给人爬了。一会限制访问一会网站验证的。任重而道远啊。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/28/computer-system/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李书赫">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404 Not Found">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/28/computer-system/" itemprop="url">computer system</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-28T23:54:50+08:00">
                2019-06-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Reference: comptuer system: a programmer’s perspective<br>Related course: <a href="https://ipads.se.sjtu.edu.cn/courses/ics/" target="_blank" rel="noopener">Introduction to computer systems</a></p>
<h3 id="Memory-hierarchy"><a href="#Memory-hierarchy" class="headerlink" title="Memory hierarchy"></a>Memory hierarchy</h3><p>memory = RAM + ROM + Hard Disk</p>
<h4 id="RAM"><a href="#RAM" class="headerlink" title="RAM"></a>RAM</h4><p>RAM = DRAM + SRAM<br>RAM is volatile memories -&gt; loss data if powered off</p>
<table>
<thead>
<tr>
<th>category</th>
<th>transistor per bit</th>
<th>access time</th>
<th>persist</th>
<th>sensitive</th>
<th>cost</th>
<th>applications</th>
</tr>
</thead>
<tbody><tr>
<td>SRAM</td>
<td>6</td>
<td>fastest</td>
<td>yes</td>
<td>no</td>
<td>expensive</td>
<td>cache</td>
</tr>
<tr>
<td>DRAM</td>
<td>1</td>
<td>fast</td>
<td>no</td>
<td>yes</td>
<td>less exp</td>
<td>main memories</td>
</tr>
</tbody></table>
<h4 id="ROM"><a href="#ROM" class="headerlink" title="ROM"></a>ROM</h4><p>ROM is nonvolatile memories<br>ROM:BIOS, graphics card, disk controllers</p>
<p>Hard disk = several platters<br>platter = 2 surfaces<br>surface = multiple tracks<br>track = lots of sectors</p>
<p>Access time = seek time (seek for track) + rotation time (wait for sector) + transfer time (data transfer)<br>Example: T = 9ms + 4ms + 0.02ms -&gt; seek time and rotation time dominate the access time.</p>
<p>I/O port: address reserved for the communication between cpu and I/O device.</p>
<p>Routine for cpu access disk:</p>
<ol>
<li>cpu initiates a disk read by writing a command, logical block number and destination memory address to a port</li>
<li>Disk controller reads sector and perform a DMA (no CPU) transfer into main memory(RAM).</li>
<li>Disk controller send interrupt to cpu. (could be singal in pin or information on bus).</li>
<li>CPU read from memory.</li>
</ol>
<p><img src="architecture.png" alt></p>
<h4 id="SSD"><a href="#SSD" class="headerlink" title="SSD"></a>SSD</h4><p>SSD stands for Solid State Disk. It is a storage technology based on flash memory.<br>Charasteristic of SSD: </p>
<ol>
<li>Data read/write in units of pages(pages form block)</li>
<li>Page can be written only after the blocks are erased.</li>
<li>Could be wears out.</li>
<li>No moving part-&gt;faster, less power.</li>
</ol>
<p>The gap between the speed of CPU and memory is widthen. We use locality and memory hierarchy to decrease the time of memory process.<br>Locality: Pragrams tend to use data and instructions with address near or equal to those they have used recently.<br>Temporal locality: recently used.<br>Spatial locality: nearby.</p>
<p>![](memory_hierarchy.png]<br>Memory hierarchy: Register-&gt;L1, L2, L3 cache(SRAM)-&gt;Main memory(DRAM)-&gt;Local disks.<br>Low level memory serves as caches for high level memory.<br>Because of the locality, hierarchy memory could be a good solution for fasten the progress on memory.</p>
<p>Generic Cache memory organization:<br>cache = sets = valid(1bit) + tag(block index in physical memory) + blocks<br>physical address = tag(block index) + set index + block offset</p>
<p>physical address -&gt; cache:<br>select set -&gt; Line matching(valid number, tag) -&gt; word extraction(according to block offset)</p>
<h3 id="Read"><a href="#Read" class="headerlink" title="Read"></a>Read</h3><p>conflict-&gt;same cache lines will be filled by different physical address multiple times.</p>
<p>Why using middle bits as index? the middle bits will make the physical memory caches mapping more fluent. Consecutive memory lines map to different caches lines.</p>
<p>To find the lines in same set. Using tags.</p>
<p>The physical memory will only determine which sets will be used. If all the lines in the same sets are filled, which line will be evicted?<br>LFU: least frequently used.<br>LRU: least recently used.</p>
<p>Set associative caches: several sets. each set contains several lines.<br>Fully associative caches: one sets. contain all the lines.</p>
<h3 id="Write"><a href="#Write" class="headerlink" title="Write"></a>Write</h3><p>Modern Implementation: write back, write allocate<br>write through: cpu write into caches and copy data from caches into memory.<br>write back: cpu write into caches, copy data into memory only if the caches will be evicted.<br>write allocate: land the corrend memory block into cache, then updates the cache block.<br>no-write-allocate: bypass the cache and write toe word directly memory.</p>
<p>Miss rate: memory not found in cache. 3-10% for L1. can be small for L2.<br>Hit rate: fraction of memory found in cache(1-Miss rage).<br>Hit time: time to deliver a line in the cache to processor.<br>Miss Penalty: additional time required because of a miss.</p>
<p>How to write cache-frendly code? better locality. lower miss rates.<br>Temporal locality: repeated references to local variables-&gt;compiler will cache the data in register.<br>Spatial locality: stride-1 references patterns-&gt;contiguous blocks will be stored in caches.</p>
<p><img src="cpu_architecture.jpg" alt></p>
<h3 id="Linking"><a href="#Linking" class="headerlink" title="Linking"></a>Linking</h3><p>Linking can be performed 1. at compile time(static linking). 2. at load time(load time dynamic linking). 3. at run time(run-time dynamic link).<br>compiling: preprocessor(cpp), compiler(cc1), assembler(as), linker(ld).</p>
<h4 id="Static-Linking"><a href="#Static-Linking" class="headerlink" title="Static Linking"></a>Static Linking</h4><p>relocatable object files(*.o) -&gt; Fully linked executable object<br>Esternal reference: reference to a symbol defined in another object file. (values close to 0).<br>Symbol resolution: resolved external references.</p>
<h4 id="Dynamic-linking"><a href="#Dynamic-linking" class="headerlink" title="Dynamic linking"></a>Dynamic linking</h4><p>DLL/so files that will be load at run time or load time. For load time dynamic linking, there is a stub in the binary code that tell the system to load some resource from the shared library. Only after the resource is loaded, the program will start to run.<br>Run-time dynamic linking do not ask system to load resource at load time. In windows, GetProcAddress API will load the library at run time.</p>
<h4 id="Executable-and-linkable-format"><a href="#Executable-and-linkable-format" class="headerlink" title="Executable and linkable format"></a>Executable and linkable format</h4><p>standard binary format for object files. Unified format for relocatable object(.o), executable object files and shared object files(.so).</p>
<h4 id="Command-in-GCC"><a href="#Command-in-GCC" class="headerlink" title="Command in GCC"></a>Command in GCC</h4><p>Create dynamic library in GCC:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared hello.c -o libhello.so</span><br></pre></td></tr></table></figure>

<p>Link libhello.so to executable:<br>-l link library. -L library position. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc test.c -lhello -L.</span><br></pre></td></tr></table></figure>

<p>create static library in GCC:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c hello.c -o libhello.o</span><br></pre></td></tr></table></figure>

<p>Link libhello.o to executable:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc test.c libhello.o</span><br></pre></td></tr></table></figure>

<h3 id="Operating-system"><a href="#Operating-system" class="headerlink" title="Operating system"></a>Operating system</h3><p>Abstractions provided by OS<br><img src="os_abstractions.png" alt></p>
<h4 id="classes-of-exceptions"><a href="#classes-of-exceptions" class="headerlink" title="classes of exceptions"></a>classes of exceptions</h4><h5 id="synchronous-exceptions"><a href="#synchronous-exceptions" class="headerlink" title="synchronous exceptions"></a>synchronous exceptions</h5><p>caused by events as the result of executing an instruction.</p>
<h6 id="traps"><a href="#traps" class="headerlink" title="traps"></a>traps</h6><p>intentional. returns control to next instruction. (breakpoint)</p>
<h6 id="faults"><a href="#faults" class="headerlink" title="faults"></a>faults</h6><p>unintentional but possibly recoverable. page faults.<br>page fault: the memory address requested is not available.<br>case 1: the address is invalid -&gt; segmentation fault(SIGSEG).<br>case 2(minor): the page is loaded in memory but it is not marked in memory management unit -&gt; register in MMU.<br>case 3(major): the page is not loaded -&gt; load page from disk.</p>
<p>For case 1, the OS will send SIGSEG to the process and terminate the process. Thus unrecoverable.<br>For case2, case 3, the OS will do the corresponding handle and return the instructions points. Thus the instruction will do again.</p>
<h6 id="aborts"><a href="#aborts" class="headerlink" title="aborts"></a>aborts</h6><p>unintentional and unrecoverable. parity error.</p>
<h5 id="Asynchronous-exceptions"><a href="#Asynchronous-exceptions" class="headerlink" title="Asynchronous exceptions"></a>Asynchronous exceptions</h5><p>caused by events external to the processor.<br>Examples: 1. IO interrupts(ctrl-c). 2. hard reset interrupt(reset button). 3. soft reset interrupt(ctrl-alt-delete).<br><img src="fault.png" alt></p>
<h3 id="process"><a href="#process" class="headerlink" title="process"></a>process</h3><p>scheduler(parts of kernel) will do following things.</p>
<ol>
<li>decides whether to preempt the current process</li>
<li>selects a previously preempted process</li>
<li>preempts the current process</li>
<li>restart the scheduled process</li>
</ol>
<p>In order to restart the preempted process, context need to be stored.<br>context contains: </p>
<ol>
<li>cpu (register, value, status)</li>
<li>kernel (environment valiables, process table, page table, file table)</li>
<li>memory (user’s stack, kernel’s stack, code, data)</li>
</ol>
<p>context switch:</p>
<ol>
<li>system call(read, sleep)</li>
<li>timer interrupt (scheduler)</li>
</ol>
<table>
<thead>
<tr>
<th>process status</th>
<th>action</th>
</tr>
</thead>
<tbody><tr>
<td>stop</td>
<td>receiving a signal(SIGSTOP, SIGTSTP, SITTTIN, SIGTTOU)</td>
</tr>
<tr>
<td>running</td>
<td>receiving a SIGCONT</td>
</tr>
<tr>
<td>terminated</td>
<td>exit(), return from main, signal</td>
</tr>
</tbody></table>
<p>fork(void): return 0 to child, PID to parent, -1 for error.<br>clone all the data in parent process except pid.</p>
<p>two process can share files for communicate. (stdout)</p>
<h4 id="Zombie"><a href="#Zombie" class="headerlink" title="Zombie"></a>Zombie</h4><p>A terminated child process will become zombie if the parent has not reaped.<br>If the parent process has be terminated, kernel will assign init (pid=1) to reap them.</p>
<p>Zombie will consume system memory resources -&gt; always reap zombies.</p>
<h4 id="Process-related-API"><a href="#Process-related-API" class="headerlink" title="Process related API"></a>Process related API</h4><p>pid_t waitpid(pid_t pid, int *status, int options);<br>pid_t wait(int *status);</p>
<p>if pid &gt; 0, the process will wait for specific child.<br>if pid = -1, the process will wait any child.<br>if there is no children, return -1. errno=ECHILD(the process has no child), errno=(EINTR)interrupted by a signal.<br>options = 0. </p>
<p>unsigned int sleep(unsigned int secs);<br>int pause(void);</p>
<p>int execve(const char* filename, const char* argv[], const char* envp[]);<br>if something wrong, return -1. otherwise, never return.<br>The new program will use the same process resource. The running stack will be replaced.</p>
<h4 id="unix-shell"><a href="#unix-shell" class="headerlink" title="unix shell"></a>unix shell</h4><p>application level program.<br>compare: kernel is the core of OS whoes jobs are managing the hardware resource. </p>
<p>variants of shell: bash, sh, csh, tcsh.</p>
<p>performs a sequence of read/evaluate steps and terminate. read: reads a command line. evalute: parse the command line and runs programs.</p>
<h3 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h3><h4 id="System-level-I-O-UNIX-IO"><a href="#System-level-I-O-UNIX-IO" class="headerlink" title="System-level I/O (UNIX IO)"></a>System-level I/O (UNIX IO)</h4><p>In Unix, all IO devices are modeled as files.<br>A socket is a file that is used to communicate with another process across a network. (other types include named pips, symbolic links, character and block devices)</p>
<p>Kernal data structure for files<br>Descriptor table: every process has one. index is descriptor, point to file table.<br>File table: opened file has one or more, shared by all process. file position, reference count, pointer to V-node table.<br>V-node table: every file has one, shared by all process. file type, file size, file access.</p>
<p>Normally, one descriptor in descriptor table corresponding to one file table(different descriptor corresponding to same file will not conflect).<br>However, dup2(fd1, fd2) will assign file table(fd1) to file table(fd2).</p>
<p>File table will be deleted by kernel if recerence count is zero.</p>
<p>Open files<br>Appication: announce intention to access an I/O device. However, the application will only keep track of descriptor. it can set the current file position explicitly by performing a seek operation.<br>Kernal: open the file, returns a small non-negative integer descriptor. keeps track of all information about the open file.<br>EOF: there is no EOF in files. It is just a condition triggered if the requested byte is more than bytes left to the end.</p>
<p>Close files:<br>application: will not access the file.<br>kernel: frees structures. restore the descriptor to a pool of available descriptor.</p>
<h4 id="RIO-Robust-IO"><a href="#RIO-Robust-IO" class="headerlink" title="RIO (Robust IO)"></a>RIO (Robust IO)</h4><p>wrappers that provide efficient and robust IO.<br>with no buff: read/write automatic deal with EINTR. EOF will return size instead of 0.<br>buff: read/write to buff. less read/write command-&gt;better performance.<br>rio_readn(int fd, void *usrbuf, size_t count)<br>rio_writen(int fd, void *usrbuf, size_t count)</p>
<h4 id="standard-IO"><a href="#standard-IO" class="headerlink" title="standard IO"></a>standard IO</h4><p>C standard library (libc.so). high level standard io.<br>abstract open files as streams -&gt; file descriptor and a buffer.<br>stdin(fd=0)<br>stdout(fd=1)<br>stderr(fd=2)<br>Similar to RIO.</p>
<pre><code>|Unix IO|standard io</code></pre><p>—–|——-|———–<br>prons|general, lowest over head. Metadata, async-signal-safe|efficiency. automatically short counts<br>cons |Shord counts is tricky and error prone. inefficient   |no metadata. not async-signal-safe. not good for network sockets</p>
<p>note: standard IO require fflush/fseek/fsetpos/rewind between write and read.</p>
<h3 id="VM"><a href="#VM" class="headerlink" title="VM"></a>VM</h3>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/28/bignumber/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李书赫">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404 Not Found">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/28/bignumber/" itemprop="url">大数相乘以及快速幂</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-28T11:59:52+08:00">
                2019-06-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/基础知识/" itemprop="url" rel="index">
                    <span itemprop="name">基础知识</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>宏观上，我们认为数的相乘为constant time，即O(1). 然而，如果考虑到数的位数，那么乘法操作就变得复杂起来。<br>如果两个长度为N的数相乘，小学所讲的乘法运算复杂度为O(n^2) –&gt; 对每一位都要进行相乘运算。<br>另一个方法是karatsuba。<br><img src="bidnumber.png" alt><br>如图所示，基础思想为divide and conquer。<br>以下为c++代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_length</span><span class="params">(<span class="keyword">long</span> num)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		num /= <span class="number">10</span>;</span><br><span class="line">		length++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">karatsuba</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">long</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// x = a * 10^(length/2) + b</span></span><br><span class="line">	<span class="comment">// y = c * 10^(length/2) + d</span></span><br><span class="line">	<span class="comment">// x * y = ac * 10^length + bd + ((a + c)*(b + d) - ac - bd)*10^(length/2)</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (x &lt; <span class="number">10</span> &amp;&amp; y &lt; <span class="number">10</span>) <span class="keyword">return</span> x * y;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// calculate a b c d</span></span><br><span class="line">	<span class="keyword">int</span> length = max(get_length(x), get_length(y));</span><br><span class="line">	<span class="keyword">int</span> t = <span class="built_in">pow</span>(<span class="number">10</span>, length / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> a = x / t;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> b = x - a * t;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> c = y / t;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> d = y - c * t;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// z1 = ac, z2 = bd, z3 = (a+c)*(b+d) - z1 - z2</span></span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> z1 = karatsuba(a, c);</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> z2 = karatsuba(b, d);</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> z3 = karatsuba((a + b), (c + d)) - z1 - z2;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> z1 * t*t + z2 + z3 * t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在写代码的时候，发现使用long并不会扩张int的取值范围。于是去百度，发现，long的位数由编译器来确定，c语言只规定long位数不低于int。<br>而我使用的VC，把long定义为4字节，同int一样。</p>
<p>快速幂：<br>求幂的时候，我们也可以用divide and conquer来缩短运算。如果把相乘看为O(1)，求N次幂显然需要O(N)次运算。<br>然而，我们可以让底数增大，这样相乘的次数就会减少。例如$2^4 = 2^2 * 2^2$.<br>于是，运算可以简化为O(logN)<br>以下是相应代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">exp</span> = <span class="built_in">abs</span>(exponent);</span><br><span class="line">    <span class="keyword">double</span> res = <span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">exp</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">exp</span> &amp; <span class="number">1</span>) res *= base;</span><br><span class="line">        base *= base;</span><br><span class="line">        <span class="built_in">exp</span> &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> exponent &lt; <span class="number">0</span>? <span class="number">1</span>/res:res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/27/memory-in-c/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李书赫">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404 Not Found">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/27/memory-in-c/" itemprop="url">C/C++中的内存管理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-27T23:00:28+08:00">
                2019-06-27
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/基础知识/" itemprop="url" rel="index">
                    <span itemprop="name">基础知识</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在了解内存管理之前，需要注意C语言中变量类型。<br>const：常数变量。static：静态变量。<br>局部变量（函数内部）。全局变量（非函数内部）。</p>
<p><img src="5memory_area.png" alt><br>可执行文件(exe)文件中储存在disk时，可以分为代码区(code area)，数据区(data area)，未初始化数据区(BSS).<br>在执行时，在系统内存中会另外生成栈区(stack)和堆区(heap)。<br>代码区：存放执行代码。有可能包含一些只读的常数变量。<br>数据区：存放已初始化全局变量，静态变量和常量数据。<br>未初始化数据区(BSS)：用来存放未初始化的全局变量。在程序运行时会对全部变量赋值0。<br>栈区(stack)：存放局部变量以及程序运行时需要的信息（包括函数调用返回地址，传递参数）。由系统自动静态分配。<br>堆区(heap)：由程序员分配释放。（malloc/free）。</p>
<p>栈/堆区别：<br>栈由系统控制分配释放，硬件方面有相应的适配，故效率极高。高地址到低地址。<br>堆有程序员控制分配释放，在执行时可能会存在碎片，因此效率相对较低。低地址到高地址。</p>
<p>内存对齐：<br>不同平台对对内存空间处理上不同。一些平台对特定类型数据只能从特定地址开始存取。<br>内存对齐可以减少读取周期，增加效率。<br>有三条规则：</p>
<ol>
<li>对于结构体，成员偏移量(内存所在位置)应为当前成员类型整数倍。</li>
<li>结构体所有数据成员对齐后，本身还要对齐，保证整个结构体占用内存大小是结构体最大数据成员的最小整数倍。</li>
<li>#pragma pack(n) 预编译指令使得所有成员对齐以n字节为准，不考虑规则二。<br>举例：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BU1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> number;             <span class="comment">//4字节</span></span><br><span class="line">    <span class="keyword">union</span> UBffer</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> buffer[<span class="number">13</span>];    <span class="comment">//填充3字节，该成员占16字节空间</span></span><br><span class="line">        <span class="keyword">double</span> number;</span><br><span class="line">    &#125;ubuf;</span><br><span class="line">    <span class="keyword">int</span> aa;                 <span class="comment">//占4字节空间,当前偏移量已补齐为24</span></span><br><span class="line">    <span class="keyword">double</span> dou;             <span class="comment">//占8字节空间</span></span><br><span class="line">&#125;bu;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>sizeof(BU1) = 4 + 4(补充) + 13 + 3(补充) + 4 + 8 + 4(补充)</p>
<pre><code class="c"><span class="class"><span class="keyword">struct</span> <span class="title">BU2</span></span>
<span class="class">{</span>
    <span class="keyword">int</span> number;             <span class="comment">//4字节</span>
    <span class="keyword">union</span> UBffer
    {
        <span class="keyword">char</span> buffer[<span class="number">13</span>];    <span class="comment">//填充3字节，该成员占16字节空间</span>
        <span class="keyword">int</span> number;
    }ubuf;
    <span class="keyword">double</span> aa;                 <span class="comment">//占8字节空间,当前偏移量已补齐为24</span>
    <span class="keyword">int</span> dou;             <span class="comment">//占4字节空间</span>
}bu;</code></pre>
<p>sizeof(BU2) = 4 + 13 + 7(补充) + 8 + 4 + 4(补充)</p>
<p>注意，如果在代码首部加上#pragma pack(1)，sizeof(BU1) = 4 + 13 + 4 + 8, sizeof(BU2) = 4 + 13 + 8 + 4</p>
<p>柔性数组机制，如果最后一个成员为数组，且大小为0，则该结构体大小不计算该数组。<br>C++中，struct本质上是public class，规定空类大小为1.<br>C中，空类大小为0.</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/27/true-complemental-ones-complemental-code/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李书赫">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404 Not Found">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/27/true-complemental-ones-complemental-code/" itemprop="url">原码，反码，补码</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-27T11:32:47+08:00">
                2019-06-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在做题的时候遇到了相互转换的问题，于是在此做一个小结。<br>原码，即为数直接转换为二进制后的编码。负数与正数的差别为负数最高为为1，正数为0.<br>正数的反码和补码与原码相同。负数的反码为除最高位全部取反。负数的补码为反码加一。<br>如：<br>-5，原码1000 0101，反码1111 1010，补码1111 1011.<br>-0，原码1000 0000，反码1111 1111，补码0000 0000.</p>
<p>127 原码0111 1111，反码0111 1111，补码0111 1111.<br>-127 原码1111 1111，反码1000 0000，补码1000 0001.<br>我们发现，1000 0000这个状态没有使用。如果我们把它当作补码。<br>最高位为1，所以是负数，相应的反码0111 1111. 相应的原码1000 0000.<br>所以，1000 0000可以表示-128的补码。</p>
<p>因此，int（32位）取值范围为$-2^{32-1} – (2^{32-1}-1)$</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/26/practice/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李书赫">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404 Not Found">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/26/practice/" itemprop="url">剑指offer</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-26T23:16:15+08:00">
                2019-06-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/剑指offer/" itemprop="url" rel="index">
                    <span itemprop="name">剑指offer</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Link: [<a href="https://www.nowcoder.com/ta/coding-interviews]" target="_blank" rel="noopener">https://www.nowcoder.com/ta/coding-interviews]</a></p>
<h2 id="1-10"><a href="#1-10" class="headerlink" title="1 - 10"></a>1 - 10</h2><h3 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h3><p>看到题的直觉是用binary search。<br>先用暴力搜索–&gt;15ms + 1484k–&gt;O(n<em>m)<br>对每一行预先判断首尾–&gt;15ms + 1376k–&gt;O(n</em>m)<br>binary search–&gt;12 + 1504k–&gt;O(n*logm)<br>最后，发现矩阵整体是有序的，因此可以由左下开始直接判断,复杂度O(n+m)</p>
<p>PS: 设置的测试方案太过简单，直接暴力搜索也不是很慢。</p>
<p>附binary search代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = <span class="built_in">array</span>.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">array</span>[i][mid] == target)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">array</span>[i][mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">array</span>[i][mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h3><p>本题较为简单，直接从后往前扫描插入即可。（如果用js/python直接用replace就好了）</p>
<h3 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h3><p>本题较为简单，通过stack使得顺序改变即可。需要注意的是，这题head里面是存数据的。</p>
<h3 id="第四题"><a href="#第四题" class="headerlink" title="第四题"></a>第四题</h3><p>由前中/中后序重构树。使用递归完成较为简单。<br>前中：1. 前序第一个一定是本节的根。2. 找到本节根在中序的位置。3. 计算左树点的数量。<br>中后：1. 后序最后一个一定是本节的根。2. 找到本节根在中序的位置。3. 计算左数点的数量。<br>附前中序代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">R</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vin, <span class="keyword">int</span> preStart, <span class="keyword">int</span> preEnd, <span class="keyword">int</span> vinStart, <span class="keyword">int</span> vinEnd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (preStart &gt;= preEnd || vinStart &gt;= vinEnd) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// search the position in vin</span></span><br><span class="line">    <span class="keyword">int</span> vinPosition = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = vinStart; i &lt; vinEnd; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (vin[i] == pre[preStart]) &#123;</span><br><span class="line">        vinPosition = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> prePosition = preStart + vinPosition - vinStart;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">node</span> = <span class="title">new</span> <span class="title">struct</span> <span class="title">TreeNode</span>(<span class="title">pre</span>[<span class="title">preStart</span>]);</span></span><br><span class="line">    node-&gt;left = R(pre, vin, preStart+<span class="number">1</span>, prePosition+<span class="number">1</span>, vinStart, vinPosition);</span><br><span class="line">    node-&gt;right = R(pre, vin, prePosition+<span class="number">1</span>, preEnd, vinPosition+<span class="number">1</span>, vinEnd);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第五题"><a href="#第五题" class="headerlink" title="第五题"></a>第五题</h3><p>此题较为简单。stack1储存，stack2给予，如果stack2为空时将stack1的点全部输入stack2即可。</p>
<h3 id="第六题"><a href="#第六题" class="headerlink" title="第六题"></a>第六题</h3><p>旋转数组找最小成分。直观做法是线性扫描–&gt;37ms.<br>稍加观察，发现出现先第一个小于首位的数即为最小–&gt;32ms.</p>
<h3 id="第七题"><a href="#第七题" class="headerlink" title="第七题"></a>第七题</h3><p>斐波那契数列。</p>
<h3 id="第八题"><a href="#第八题" class="headerlink" title="第八题"></a>第八题</h3><p>斐波那契数列变种。$F(n) = F(n-1) + F(n-2)$</p>
<h3 id="第九题"><a href="#第九题" class="headerlink" title="第九题"></a>第九题</h3><p>斐波那契数列变种。$F(n) = \sum_{k=1}^{n-1} F(k)+1$</p>
<h3 id="第九题-1"><a href="#第九题-1" class="headerlink" title="第九题"></a>第九题</h3><p>斐波那契数列变种。$F(n) = F(n-1) + F(n-2)$</p>
<h3 id="第十题"><a href="#第十题" class="headerlink" title="第十题"></a>第十题</h3><p>求二进制中1的个数。比较麻烦的是负数。有关负数补码，可以参考另一篇博客“原码，反码和补码”。<br>其实这道题还可以直接对bit操作，会简单很多。但是我觉得出题人的初衷是要考察对原反补码的理解。whatever。以下是相关代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tag&amp;n) &#123;</span><br><span class="line">            res ++;</span><br><span class="line">        &#125;</span><br><span class="line">        tag = tag &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="11-20"><a href="#11-20" class="headerlink" title="11 - 20"></a>11 - 20</h2><h3 id="第十一题"><a href="#第十一题" class="headerlink" title="第十一题"></a>第十一题</h3><p>快速幂，增大base来减少相乘的次数。详细算法可以参考“大数相乘以及快速幂”。<br>其实直接用写好的pow即可快速通过。</p>
<h3 id="第十二题"><a href="#第十二题" class="headerlink" title="第十二题"></a>第十二题</h3><p>方法一：bubble sort。左偶数右奇数-&gt;交换。O(n^2).<br>方法二：新建vector。扫描奇数，扫描偶数。O(n)。</p>
<h3 id="第十三题"><a href="#第十三题" class="headerlink" title="第十三题"></a>第十三题</h3><p>方法一：遍历，得到list的大小，再次遍历，找到size-k。<br>方法二：使用stack，全部存下，然后pop k次。<br>方法三：使用queue，如果queue大于k，pop。<br>比较：我个人最喜欢方法三，只需要一次遍历并且存下k个node。属于折中的方法。</p>
<h3 id="第十四题"><a href="#第十四题" class="headerlink" title="第十四题"></a>第十四题</h3><p>最简单的方法是使用stack存下全部node，然后再根据stack的顺序新建node。然而需要遍历两遍，且需要新建一个list。<br>也可以直接操作list，需要记录前，中，后三点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">ReverseList</span><span class="params">(ListNode* pHead)</span> </span>&#123;</span><br><span class="line">    ListNode* pre = <span class="literal">NULL</span>;</span><br><span class="line">    ListNode* current = <span class="literal">NULL</span>;</span><br><span class="line">    ListNode* post = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    current = pHead;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        post = current-&gt;next;</span><br><span class="line">        current-&gt;next = pre;</span><br><span class="line">        pre = current;</span><br><span class="line">        current = post;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第十五题"><a href="#第十五题" class="headerlink" title="第十五题"></a>第十五题</h3><p>较为简单，不做赘述。</p>
<h3 id="第十六题"><a href="#第十六题" class="headerlink" title="第十六题"></a>第十六题</h3><p>主要是对递归的理解。分为两个function。sub判断tree2是否为当前tree1的顶端。HasSubtree判断tree1是否包含tree2. 代码下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">sub</span><span class="params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root2 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root1 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root1-&gt;val == root2-&gt;val) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sub(root1-&gt;left, root2-&gt;left) &amp;&amp; sub(root1-&gt;right, root2-&gt;right)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">HasSubtree</span><span class="params">(TreeNode* pRoot1, TreeNode* pRoot2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pRoot1 == <span class="literal">NULL</span> || pRoot2 == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// case 1: same root</span></span><br><span class="line">    <span class="keyword">if</span> (sub(pRoot1, pRoot2)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// case 2: left has sub tree</span></span><br><span class="line">    <span class="keyword">if</span> (pRoot1-&gt;left != <span class="literal">NULL</span> &amp;&amp; HasSubtree(pRoot1-&gt;left, pRoot2)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// case 3: right has sub tree</span></span><br><span class="line">    <span class="keyword">if</span> (pRoot1-&gt;right != <span class="literal">NULL</span> &amp;&amp; HasSubtree(pRoot1-&gt;right, pRoot2)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第十七题"><a href="#第十七题" class="headerlink" title="第十七题"></a>第十七题</h3><p>较为简单，使用DFS遍历，然后交换左右子树。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Mirror</span><span class="params">(TreeNode *pRoot)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// terminate condition</span></span><br><span class="line">    <span class="keyword">if</span> (pRoot == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// DFS</span></span><br><span class="line">    <span class="keyword">if</span> (pRoot-&gt;left != <span class="literal">NULL</span>) Mirror(pRoot-&gt;left);</span><br><span class="line">    <span class="keyword">if</span> (pRoot-&gt;right != <span class="literal">NULL</span>) Mirror(pRoot-&gt;right);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// swqp left and right</span></span><br><span class="line">    TreeNode* tmp = pRoot-&gt;left;</span><br><span class="line">    pRoot-&gt;left = pRoot-&gt;right;</span><br><span class="line">    pRoot-&gt;right = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第十八题"><a href="#第十八题" class="headerlink" title="第十八题"></a>第十八题</h3><p>比较麻烦的简单题。有四种不同状态，判断好边界就不是很难处理。</p>
<h3 id="第十九题"><a href="#第十九题" class="headerlink" title="第十九题"></a>第十九题</h3><p>题目要求要stack查找最小值时间复杂度为O(1)。很明显要储存一些数据来支持这个结构。那么我们需要储存什么呢？来看一下需求。要求最小值时间复杂度为1，且每次pop之后，重新寻找最小值也是O(1).设置一个一模一样的结构记录每一次pop后的最小值即可完成目标。<br>简单来说就是用两个stack，一个用来存放数据，一个用来存放最小值。当新的数值小于stack2.top时，我们将新的数值push到stack2中。</p>
<h3 id="第二十题"><a href="#第二十题" class="headerlink" title="第二十题"></a>第二十题</h3><p>本题比较有趣。如果判断某序列是否可以由stack pop出，可以根据“一旦pop，stack中剩余的元素相对order不可能改变”。<br>然而，本题如果用这种方式来判断，时间复杂度为O(n^2)。<br>我们可以模拟整个stack push pop的过程，如果最终stack为空，则该序列是合法的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsPopOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pushV,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; popV)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// simulate the situation</span></span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">int</span> popPos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pushV.size(); i++) &#123;</span><br><span class="line">        s.push(pushV[i]);</span><br><span class="line">        <span class="keyword">while</span> (popPos &lt; popV.size() &amp;&amp; s.top() == popV[popPos]) &#123;</span><br><span class="line">            s.pop();</span><br><span class="line">            popPos++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.empty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="21-30"><a href="#21-30" class="headerlink" title="21 - 30"></a>21 - 30</h2><h3 id="第二十一题"><a href="#第二十一题" class="headerlink" title="第二十一题"></a>第二十一题</h3><p>BFS。使用queue来储存即可。同理，使用stack可以实现DFS。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; PrintFromTopToBottom(TreeNode* root) &#123;</span><br><span class="line">    <span class="comment">// BFS</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">    q.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        TreeNode* node = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        res.push_back(node-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            q.push(node-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            q.push(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第二十二题"><a href="#第二十二题" class="headerlink" title="第二十二题"></a>第二十二题</h3><p>递归问题。判断一个序列是否为合法的二叉搜索树后序排列，针对每一个root点，判断其前面序列是否可以分为左树和右树。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sequence, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// sequence should be able to be splitted into 2 parts</span></span><br><span class="line">    <span class="keyword">int</span> pivot = sequence[right];</span><br><span class="line">    <span class="keyword">bool</span> isLeftPart = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = left;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt; right; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isLeftPart) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sequence[i] &gt; pivot) &#123;</span><br><span class="line">                isLeftPart = <span class="literal">false</span>; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                mid = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (sequence[i] &lt; pivot) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> check(sequence, left, mid) &amp;&amp; check(sequence, mid+<span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">VerifySquenceOfBST</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sequence)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = sequence.size();</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> check(sequence, <span class="number">0</span>, size<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第二十三题"><a href="#第二十三题" class="headerlink" title="第二十三题"></a>第二十三题</h3><p>简单的DFS。但是如果用非递归方法，需要维持一些数据结构且要判断边界，很麻烦。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; FindPath(TreeNode* root,<span class="keyword">int</span> expectNumber) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> res;</span><br><span class="line">        path.push_back(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val == expectNumber &amp;&amp; root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            res.push_back(path);</span><br><span class="line">        &#125;</span><br><span class="line">        FindPath(root-&gt;left, expectNumber-root-&gt;val);</span><br><span class="line">        FindPath(root-&gt;right, expectNumber-root-&gt;val);</span><br><span class="line">        path.pop_back();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="第二十四题"><a href="#第二十四题" class="headerlink" title="第二十四题"></a>第二十四题</h3><p>想破头的题。无论如何都找不到简单的方法，查看了人家的讲解，发现是在原本linked list上进行改动。感觉巧妙的同时也感慨自己的愚鲁。<br>此处附上偷来的讲解和自己的代码。<br><img src="q24.png" alt></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">RandomListNode* <span class="title">Clone</span><span class="params">(RandomListNode* pHead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pHead == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    RandomListNode* node = pHead;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// copy all the node alone path of next</span></span><br><span class="line">        RandomListNode* newnode = <span class="keyword">new</span> RandomListNode(node-&gt;label);</span><br><span class="line">        RandomListNode* tmp = node-&gt;next;</span><br><span class="line">        node-&gt;next = newnode;</span><br><span class="line">        newnode-&gt;next = tmp;</span><br><span class="line">        node = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    node = pHead;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// copy all the node alone path of random</span></span><br><span class="line">        RandomListNode* targetNode = node-&gt;random;</span><br><span class="line">        <span class="keyword">if</span> (targetNode != <span class="literal">NULL</span>) node-&gt;next-&gt;random = targetNode-&gt;next;</span><br><span class="line">        node = node-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    RandomListNode* newhead = pHead-&gt;next;</span><br><span class="line">    RandomListNode* newnode = newhead;</span><br><span class="line">    node = pHead;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// split the list</span></span><br><span class="line">        node-&gt;next = newnode-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (newnode-&gt;next != <span class="literal">NULL</span>) newnode-&gt;next = newnode-&gt;next-&gt;next;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">        newnode = newnode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> newhead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第二十五题"><a href="#第二十五题" class="headerlink" title="第二十五题"></a>第二十五题</h3><p>中序遍历即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode* pre = <span class="literal">NULL</span>;</span><br><span class="line">    TreeNode* head = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">Convert</span><span class="params">(TreeNode* pRootOfTree)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pRootOfTree == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        Convert(pRootOfTree-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (pre == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            pre = pRootOfTree;</span><br><span class="line">            head = pRootOfTree;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            pre-&gt;right = pRootOfTree;</span><br><span class="line">            pRootOfTree-&gt;left = pre;</span><br><span class="line">            pre = pRootOfTree;</span><br><span class="line">        &#125;</span><br><span class="line">        Convert(pRootOfTree-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="第二十六题"><a href="#第二十六题" class="headerlink" title="第二十六题"></a>第二十六题</h3><p>数组中大于一半的数。<br>方法一：储存一个数，如果不一样则相互抵消，如果一样则增加计数。最后验证该数次数是否超过一半。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> current = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (current == <span class="number">-1</span>) &#123;</span><br><span class="line">            current = numbers[i];</span><br><span class="line">            count ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (current != numbers[i]) &#123;</span><br><span class="line">                count --;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                count ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                current = numbers[i];</span><br><span class="line">                count ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (numbers[i] == current) &#123;</span><br><span class="line">            count ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (count &gt; numbers.size()/<span class="number">2</span>) <span class="keyword">return</span> current;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二：排序，选取中间的数。但是此法为O(nlogn)。复杂度较高。附quicksort代码。</p>
<p>第二十七题<br>递归来做。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">notFound</span><span class="params">(<span class="built_in">string</span>&amp; str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rstr.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str == rstr[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pen</span><span class="params">(<span class="built_in">string</span>&amp; str, <span class="keyword">int</span> begin)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (begin &gt;= str.size()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (notFound(str)) rstr.push_back(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = begin; i &lt; str.size(); i++) &#123;</span><br><span class="line">            swap(str, begin, i);</span><br><span class="line">            pen(str, begin + <span class="number">1</span>);</span><br><span class="line">            swap(str, begin, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="built_in">string</span>&amp; str, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> tmp = str[i];</span><br><span class="line">        str[i] = str[j];</span><br><span class="line">        str[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; Permutation(<span class="built_in">string</span> str) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str.size() == <span class="number">0</span>) <span class="keyword">return</span> rstr;</span><br><span class="line">        pen(str, <span class="number">0</span>);</span><br><span class="line">        sort(rstr.begin(), rstr.end());</span><br><span class="line">        <span class="keyword">return</span> rstr;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; rstr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="第二十八题"><a href="#第二十八题" class="headerlink" title="第二十八题"></a>第二十八题</h3><p>构建总数为K的最大heap。对每一个元素和heap比较，如果比堆顶小，则替换，重新排列heap。复杂度为O(nlogk)。<br>然而我用了暴力搜索，AC。大概是结果设置的太简单了。附k堆的代码。</p>
<h3 id="第二十九题"><a href="#第二十九题" class="headerlink" title="第二十九题"></a>第二十九题</h3><p>很简单的动态规划题。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> greatestSumForPosition = <span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> res = greatestSumForPosition;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="built_in">array</span>.size(); i++) &#123;</span><br><span class="line">        greatestSumForPosition = max(greatestSumForPosition + <span class="built_in">array</span>[i], <span class="built_in">array</span>[i]);</span><br><span class="line">        res = max(res, greatestSumForPosition);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第三十题"><a href="#第三十题" class="headerlink" title="第三十题"></a>第三十题</h3><p>归纳法，按照每一位来计算。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (tmp &lt;= n) &#123;</span><br><span class="line">        count += (n/(<span class="number">10</span>*tmp)) * tmp;</span><br><span class="line">        <span class="keyword">if</span> (n%(<span class="number">10</span>*tmp) &lt; tmp) &#123;</span><br><span class="line">            count += <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (n%(<span class="number">10</span>*tmp) &lt; <span class="number">2</span>*tmp) &#123;</span><br><span class="line">            count += n%(<span class="number">10</span>*tmp)-(tmp<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            count += tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp *= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="31-40"><a href="#31-40" class="headerlink" title="31 - 40"></a>31 - 40</h2><h3 id="第三十一题"><a href="#第三十一题" class="headerlink" title="第三十一题"></a>第三十一题</h3><p>简单来说就是对数的排序。即从最高位到最低位的排序。我贴上两种做法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gter</span> &#123;</span></span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="built_in">string</span> a, <span class="built_in">string</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> acount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> bcount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (acount &lt; a.size()<span class="number">-1</span> &amp;&amp; bcount &lt; b.size()<span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a.at(acount) != b.at(bcount)) <span class="keyword">return</span> a.at(acount) &gt; b.at(bcount);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (acount &lt; a.size()<span class="number">-1</span>) acount ++;</span><br><span class="line">                <span class="keyword">if</span> (bcount &lt; b.size()<span class="number">-1</span>) bcount ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  a.at(acount) &gt; b.at(bcount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">PrintMinNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; strings;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.size(); i++) &#123;</span><br><span class="line">            <span class="built_in">string</span> tmp = to_string(numbers[i]);</span><br><span class="line">            strings.push_back(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// sort(strings.begin(), strings.end(), gter());</span></span><br><span class="line">		sort(<span class="built_in">string</span>.begin(), strings.end(), gt);</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = strings.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            res.append(strings[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">gt</span><span class="params">(<span class="built_in">string</span> a, <span class="built_in">string</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> c = a + b;</span><br><span class="line">        <span class="built_in">string</span> d = b + a;</span><br><span class="line">        <span class="keyword">return</span> c &gt; d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="第三十二题"><a href="#第三十二题" class="headerlink" title="第三十二题"></a>第三十二题</h3><p>丑数。很明显，后面的数要由前面数产生。那么如何产生呢？基本上这类题的做法都是维持一个数列，每一次push一个最小的候选人。难点在于确定候选人。<br>很明显，候选人=前人<em>2或者前人</em>3 或者前人<em>5。前人可以是数组中任意的数，那么复杂度为O(n^2)。<br>然而，稍加思考，便可以得知，有很多都不必要验证。比如上一次选择的是2</em>3，那么对于前人*3这个选项，2就可以被剔除掉。因此，只需要维持三个pointer即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetUglyNumber_Solution</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; uglyNumber;</span><br><span class="line">    <span class="keyword">int</span> base = <span class="number">1</span>;</span><br><span class="line">    uglyNumber.push_back(base);</span><br><span class="line">    <span class="keyword">int</span> ptr2=<span class="number">0</span>, ptr3=<span class="number">0</span>, ptr5=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (uglyNumber.size() &lt; index) &#123;</span><br><span class="line">        <span class="comment">// select the minimum of ptr2, 3, 5</span></span><br><span class="line">        uglyNumber.push_back(min(min(uglyNumber[ptr2]*<span class="number">2</span>, uglyNumber[ptr3]*<span class="number">3</span>), uglyNumber[ptr5]*<span class="number">5</span>));</span><br><span class="line">        <span class="keyword">if</span> (uglyNumber[ptr2]*<span class="number">2</span> == uglyNumber.back()) ptr2++;</span><br><span class="line">        <span class="keyword">if</span> (uglyNumber[ptr3]*<span class="number">3</span> == uglyNumber.back()) ptr3++;</span><br><span class="line">        <span class="keyword">if</span> (uglyNumber[ptr5]*<span class="number">5</span> == uglyNumber.back()) ptr5++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> uglyNumber.back();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第三十三题"><a href="#第三十三题" class="headerlink" title="第三十三题"></a>第三十三题</h3><p>找只出现一次的数。很明显是线性时间。使用bucket sort 来储存出现的个数（使用map也可以，不过map的开销更大）。</p>
<h3 id="第三十四题"><a href="#第三十四题" class="headerlink" title="第三十四题"></a>第三十四题</h3><p>很恐怖的一道题。算法还是比较简单的，用merge sort 的思想，在合并的时候从最后一个单位开始比较。一次比较可以增加size/2个逆序数组。<br>值得注意的是，在递归的时候一定要用引用！</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> cnt;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cp;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">InversePairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data)</span> </span>&#123;</span><br><span class="line">		cnt = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">// reverse(data.begin(), data.end());</span></span><br><span class="line">		cp = data;</span><br><span class="line">		mergeSort(data, <span class="number">0</span>, data.size());</span><br><span class="line">		<span class="keyword">return</span> cnt % <span class="number">1000000007</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; data, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (end - start &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">		mergeSort(data, start, mid);</span><br><span class="line">		mergeSort(data, mid, end);</span><br><span class="line">		<span class="keyword">int</span> ptr1 = mid - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> ptr2 = end - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> ptr = end - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (ptr1 &gt;= start &amp;&amp; ptr2 &gt;= mid) &#123;</span><br><span class="line">			<span class="keyword">if</span> (cp[ptr1] &gt; cp[ptr2]) &#123;</span><br><span class="line">				data[ptr--] = cp[ptr1--];</span><br><span class="line">				cnt += ptr2 - mid + <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				data[ptr--] = cp[ptr2--];</span><br><span class="line">			&#125;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="keyword">for</span> (;ptr1 &gt;= start;ptr1--) &#123;</span><br><span class="line">			data[ptr--] = cp[ptr1];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(;ptr2 &gt;= mid; ptr2--) &#123;</span><br><span class="line">			data[ptr--] = cp[ptr2];</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">            cp[i] = data[i];</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="第三十五题"><a href="#第三十五题" class="headerlink" title="第三十五题"></a>第三十五题</h3><p>本题比较简单。扫描得到长度，然后再扫描一次即可。</p>
<h3 id="第三十六题"><a href="#第三十六题" class="headerlink" title="第三十六题"></a>第三十六题</h3><p>binary search。</p>
<h3 id="第三十七题"><a href="#第三十七题" class="headerlink" title="第三十七题"></a>第三十七题</h3><p>两种做法，第一种递归。比较简单。第二种bfs，需要控制几个变量来记录第几层。</p>
<h3 id="第三十八题"><a href="#第三十八题" class="headerlink" title="第三十八题"></a>第三十八题</h3><p>方法一：直接递归，每一次求子树高度。但是balance要便利一遍，每个点都要求一次深度，所以复杂度为O(n^2).<br>方法二：直接求深度，如果左右子树不符合要求，直接返回false即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsBalanced_Solution</span><span class="params">(TreeNode* pRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> height(pRoot) != <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">height</span><span class="params">(TreeNode* pRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pRoot == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = height(pRoot-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = height(pRoot-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (right == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">abs</span>(left-right)&lt;=<span class="number">1</span>) ? max(left, right) + <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="第三十九题"><a href="#第三十九题" class="headerlink" title="第三十九题"></a>第三十九题</h3><p>方法一，直接用map。bucket sort的思想。扫描两次即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FindNumsAppearOnce</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data,<span class="keyword">int</span>* num1,<span class="keyword">int</span> *num2)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.size(); i++) &#123;</span><br><span class="line">        mp[data[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> firstNum = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mp[data[i]] == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (firstNum) &#123;</span><br><span class="line">                *num1 = data[i];</span><br><span class="line">                firstNum = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                *num2 = data[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二，利用xor，一定是奇数个数字的结果。同样是扫描两次，由于不用构建map，速度会快很多。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FindNumsAppearOnce</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data,<span class="keyword">int</span>* num1,<span class="keyword">int</span> *num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> bitResult = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.size(); i++) &#123;</span><br><span class="line">            bitResult ^= data[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// find the one position that is 1 in bitResult</span></span><br><span class="line">        *num1 = <span class="number">0</span>;</span><br><span class="line">        *num2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> index = findPos(bitResult);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isFirst(data[i], index)) &#123;</span><br><span class="line">                (*num1) ^= data[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                (*num2) ^= data[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findPos</span><span class="params">(<span class="keyword">int</span> bitResult)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((bitResult &amp; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp; index &lt; <span class="number">32</span>) &#123;</span><br><span class="line">            index ++;</span><br><span class="line">            bitResult &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isFirst</span><span class="params">(<span class="keyword">int</span> bitResult, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = bitResult &gt;&gt; index;</span><br><span class="line">        <span class="keyword">return</span> num&amp;<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="第四十题"><a href="#第四十题" class="headerlink" title="第四十题"></a>第四十题</h3><p>比较简单，求中间数字，要注意边界。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; FindContinuousSequence(<span class="keyword">int</span> sum) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; (sum/i) &gt;= (i/<span class="number">2</span>); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = sum / i;</span><br><span class="line">        <span class="keyword">if</span> (i%<span class="number">2</span>==<span class="number">0</span> &amp;&amp; ((sum%i)*<span class="number">2</span>==i) &amp;&amp; (sum/i)-(i/<span class="number">2</span>) + <span class="number">1</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = (sum/i)-(i/<span class="number">2</span>) + <span class="number">1</span>; j &lt; (sum/i)+(i/<span class="number">2</span>)+<span class="number">1</span>; j++) &#123;</span><br><span class="line">                v.push_back(j);</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i%<span class="number">2</span>==<span class="number">1</span> &amp;&amp; ((sum%i)==<span class="number">0</span>) &amp;&amp; (sum/i)-(i/<span class="number">2</span>)&gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = (sum/i)-(i/<span class="number">2</span>); j &lt; (sum/i)+(i/<span class="number">2</span>)+<span class="number">1</span>; j++) &#123;</span><br><span class="line">                v.push_back(j);</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(res.begin(), res.end());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="41-50"><a href="#41-50" class="headerlink" title="41 - 50"></a>41 - 50</h2><h3 id="第四十一题"><a href="#第四十一题" class="headerlink" title="第四十一题"></a>第四十一题</h3><p>维持两个指针，保证右端一定大于左端。从左到右扫描数组，对每一个数A，从右到左扫描数B。<br>线性时间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; FindNumbersWithSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">array</span>,<span class="keyword">int</span> sum) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">array</span>.size() == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = <span class="built_in">array</span>.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line">    <span class="keyword">for</span> (left = <span class="number">0</span>; left &lt; (right - left) / <span class="number">2</span> + <span class="number">1</span>; left++) &#123;</span><br><span class="line">        tmp = sum - <span class="built_in">array</span>[left];</span><br><span class="line">        <span class="keyword">if</span> (sum % <span class="built_in">array</span>[left] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="built_in">array</span>[right] &gt; tmp &amp;&amp; right &gt; left) &#123;</span><br><span class="line">                right --;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">array</span>[right] == tmp) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (left &lt; <span class="built_in">array</span>.size() &amp;&amp; right &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">array</span>[left] + <span class="built_in">array</span>[right] == sum) &#123;</span><br><span class="line">            res.push_back(<span class="built_in">array</span>[left]);</span><br><span class="line">            res.push_back(<span class="built_in">array</span>[right]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第四十二题"><a href="#第四十二题" class="headerlink" title="第四十二题"></a>第四十二题</h3><p>简单的做法就是用辅助数组，然后线性扫描即可。<br>但是上述做法需要额外的空间，还有一种不需要空间的做法。YX = (XT YT)T<br>即对前后分别做反转，然后对全部做反转。需要扫描三次，但是不需要空间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">LeftRotateString</span><span class="params">(<span class="built_in">string</span> str, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// YX = (XT YT)T</span></span><br><span class="line">    <span class="keyword">int</span> size = str.size();</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    n = n % size;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = n - <span class="number">1</span>; i &lt; j; i++, j--) swap(str[i], str[j]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n, j = size - <span class="number">1</span>; i &lt; j; i++, j--) swap(str[i], str[j]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = size - <span class="number">1</span>; i &lt; j; i++, j--) swap(str[i], str[j]);</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第四十三题"><a href="#第四十三题" class="headerlink" title="第四十三题"></a>第四十三题</h3><p>注意系数即可完成。比较简单。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">ReverseSentence</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> size = str.size();</span><br><span class="line">	<span class="keyword">if</span> (size == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">	<span class="function"><span class="built_in">string</span> <span class="title">res</span><span class="params">(str)</span></span>;</span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">		<span class="comment">// scan from last to front</span></span><br><span class="line">		<span class="keyword">if</span> (str[i] == <span class="string">' '</span>) &#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			<span class="comment">// copy to last pos</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; str[j] != <span class="string">' '</span> &amp;&amp; j &lt; size; j++) res[count++] = str[j];</span><br><span class="line">			res[count++] = <span class="string">' '</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (str[i] == <span class="string">' '</span>) <span class="keyword">break</span>;</span><br><span class="line">		res[count++] = str[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第四十四题"><a href="#第四十四题" class="headerlink" title="第四十四题"></a>第四十四题</h3><p>比较简单。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsContinuous</span><span class="params">( <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = numbers.size();</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    sort(numbers.begin(), numbers.end());</span><br><span class="line">    <span class="keyword">int</span> godnum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (numbers[i] == <span class="number">0</span>) godnum++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = max(<span class="number">1</span>, i+<span class="number">1</span>); j &lt; size; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (numbers[j] == numbers[j<span class="number">-1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        count += (numbers[j] - numbers[j<span class="number">-1</span>] - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count &lt;= godnum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第四十五题"><a href="#第四十五题" class="headerlink" title="第四十五题"></a>第四十五题</h3><p>简单做法当然是模拟。构建数组然后循环。但是这种题明显是可以从公式中推出来的。<br>约瑟夫环${f(n,m)=(f(n-1,m)+m)%n}$<br>由此可以写出递归代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> (m%n+LastRemaining_Solution(n<span class="number">-1</span>, m))%n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第四十六题"><a href="#第四十六题" class="headerlink" title="第四十六题"></a>第四十六题</h3><p>卡了半个小时，看了各位大佬的做法，心态有点小崩。任重而道远啊。<br>方法一：使用sizeof模拟乘法，使用位数移动模拟除法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Sum_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> a[n][n+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="keyword">sizeof</span>(a) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二：使用&amp;&amp;短路的特性模拟if</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Sum_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = n;</span><br><span class="line">    <span class="keyword">int</span> ans = (n &gt; <span class="number">0</span>) &amp;&amp; (sum += Sum_Solution(n<span class="number">-1</span>));</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第四十七题"><a href="#第四十七题" class="headerlink" title="第四十七题"></a>第四十七题</h3><p>很明显是要从bit位来作。<br>二进制加法，如果xor结果为1，则不进位。结果相应位应为1.<br>如果and结果为1，则需要进位，结果高一位应为1.<br>那么如何把这两个结合到一起呢？用一个循环直到xor等于0就好了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (num2) &#123;</span><br><span class="line">        <span class="keyword">int</span> xort = num1 ^ num2;</span><br><span class="line">        num2 = (num1 &amp; num2) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        num1 = xort;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第四十八题"><a href="#第四十八题" class="headerlink" title="第四十八题"></a>第四十八题</h3><p>每一位来转换。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StrToInt</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// check if the input is valid</span></span><br><span class="line">	<span class="keyword">int</span> ch = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> startPos = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (str[<span class="number">0</span>] == <span class="string">'+'</span>) &#123;</span><br><span class="line">		ch = <span class="number">1</span>;</span><br><span class="line">		startPos = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (str[<span class="number">0</span>] == <span class="string">'-'</span>) &#123;</span><br><span class="line">		ch = <span class="number">-1</span>;</span><br><span class="line">		startPos = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = startPos; i &lt; str.size(); i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!(str[i] &gt;= <span class="string">'0'</span> &amp;&amp; str[i] &lt;= <span class="string">'9'</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = startPos; i &lt; str.size(); i++) &#123;</span><br><span class="line">		res *= <span class="number">10</span>;</span><br><span class="line">		res += (str[i] - <span class="string">'0'</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res * ch;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第四十九题"><a href="#第四十九题" class="headerlink" title="第四十九题"></a>第四十九题</h3><p>bucket sort的思想。如果已经有数，返回。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[], <span class="keyword">int</span> length, <span class="keyword">int</span>* duplication)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (numbers[numbers[i]] == numbers[i] &amp;&amp; numbers[i] != i) &#123;</span><br><span class="line">            *duplication = numbers[i];</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = numbers[numbers[i]];</span><br><span class="line">            numbers[numbers[i]] = numbers[i];</span><br><span class="line">            numbers[i] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第五十题"><a href="#第五十题" class="headerlink" title="第五十题"></a>第五十题</h3><p>很有趣的一道题。要用reuse的思想。如何reuse之前的结果呢？以下图说明了做法。<br><img src="49.jpg" alt></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; multiply(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; B;</span><br><span class="line">    B.push_back(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; A.size(); i++) &#123;</span><br><span class="line">        B.push_back(B.back()*A[i<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    C.push_back(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = A.size() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        C.push_back(C.back()*A[i+<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size(); i++) &#123;</span><br><span class="line">        B[i] *= C[A.size() - i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> B;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="51-60"><a href="#51-60" class="headerlink" title="51 - 60"></a>51 - 60</h2><h3 id="第五十一题"><a href="#第五十一题" class="headerlink" title="第五十一题"></a>第五十一题</h3><p>正则表达式，递归来做。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">match</span><span class="params">(<span class="keyword">char</span>* str, <span class="keyword">char</span>* pattern)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="string">" "</span> &lt;&lt; pattern;</span><br><span class="line">	<span class="keyword">if</span> (str[<span class="number">0</span>] == <span class="number">0</span> &amp;&amp; pattern[<span class="number">0</span>] == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">if</span> (pattern[<span class="number">0</span>] &amp;&amp; pattern[<span class="number">1</span>] == <span class="string">'*'</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (match(str, pattern + <span class="number">2</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (str[<span class="number">0</span>] &amp;&amp; (str[<span class="number">0</span>] == pattern[<span class="number">0</span>] || pattern[<span class="number">0</span>] == <span class="string">'.'</span>)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (match(str + <span class="number">1</span>, pattern + <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">if</span> (pattern[<span class="number">1</span>] == <span class="string">'*'</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (match(str + <span class="number">1</span>, pattern)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第五十二题"><a href="#第五十二题" class="headerlink" title="第五十二题"></a>第五十二题</h3><p>注意细节。分几个case<br>case1. integer（+/- [1-9][0-9]* or 0)<br>case2. float (+/- [0-9]<em>.[0-9]</em>)
case3. e (float E integer)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isInteger</span><span class="params">(<span class="keyword">char</span>* <span class="built_in">string</span>, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> startPos = start;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">string</span>[startPos] == <span class="string">'+'</span> || <span class="built_in">string</span>[startPos] == <span class="string">'-'</span>) startPos += <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">string</span>[startPos] &gt;= <span class="string">'1'</span> &amp;&amp; <span class="built_in">string</span>[startPos] &lt;= <span class="string">'9'</span>) &#123;</span><br><span class="line">		<span class="keyword">bool</span> pureNumber = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = startPos + <span class="number">1</span>; i &lt; end; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!(<span class="built_in">string</span>[i] &gt;= <span class="string">'0'</span> &amp;&amp; <span class="built_in">string</span>[i] &lt;= <span class="string">'9'</span>)) &#123;</span><br><span class="line">				pureNumber = <span class="literal">false</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (pureNumber) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">string</span>[startPos] == <span class="string">'0'</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (startPos + <span class="number">1</span> == end) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isNumber</span><span class="params">(<span class="keyword">char</span>* <span class="built_in">string</span>, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!(<span class="built_in">string</span>[i] &gt;= <span class="string">'0'</span> &amp;&amp; <span class="built_in">string</span>[i] &lt;= <span class="string">'9'</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isFloat</span><span class="params">(<span class="keyword">char</span>* <span class="built_in">string</span>, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> startPos = start;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">string</span>[startPos] == <span class="string">'+'</span> || <span class="built_in">string</span>[startPos] == <span class="string">'-'</span>) startPos = startPos + <span class="number">1</span>;</span><br><span class="line">	<span class="comment">// scan for point</span></span><br><span class="line">	<span class="keyword">int</span> pos = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = startPos; i &lt; end; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">string</span>[i] == <span class="string">'.'</span>) &#123;</span><br><span class="line">			pos = i;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (pos != <span class="number">-1</span> &amp;&amp; (isInteger(<span class="built_in">string</span>, start, pos) || pos == startPos) &amp;&amp; isNumber(<span class="built_in">string</span>, pos + <span class="number">1</span>, end)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isNumeric</span><span class="params">(<span class="keyword">char</span>* <span class="built_in">string</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> size = <span class="built_in">strlen</span>(<span class="built_in">string</span>);</span><br><span class="line">	<span class="keyword">if</span> (size &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (isInteger(<span class="built_in">string</span>, <span class="number">0</span>, size)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">if</span> (isFloat(<span class="built_in">string</span>, <span class="number">0</span>, size)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// scan for 'e' 'E'</span></span><br><span class="line">	<span class="keyword">int</span> pos = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">string</span>[i] == <span class="string">'e'</span> || <span class="built_in">string</span>[i] == <span class="string">'E'</span>) &#123;</span><br><span class="line">			pos = i;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (pos != <span class="number">-1</span> &amp;&amp; (isFloat(<span class="built_in">string</span>, <span class="number">0</span>, pos) || isInteger(<span class="built_in">string</span>, <span class="number">0</span>, pos)) &amp;&amp; isInteger(<span class="built_in">string</span>, pos + <span class="number">1</span>, size)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第五十三题"><a href="#第五十三题" class="headerlink" title="第五十三题"></a>第五十三题</h3><p>比较简单。因为给定的是char，所以用bucket sort计数即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">  <span class="comment">//Insert one char from stringstream</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> ch)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (cnt[ch] == <span class="number">0</span>)</span><br><span class="line">			str.push_back(ch);</span><br><span class="line">        cnt[ch] ++;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//return the first appearence once char in current stringstream</span></span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">FirstAppearingOnce</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (ptr &lt; str.size() &amp;&amp; cnt[str[ptr]] != <span class="number">1</span>) &#123;</span><br><span class="line">            ptr++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (str.size() == ptr) <span class="keyword">return</span> <span class="string">'#'</span>;</span><br><span class="line">        <span class="keyword">return</span> str[ptr];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; str;</span><br><span class="line">    <span class="keyword">char</span> cnt[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">int</span> ptr=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="第五十四题"><a href="#第五十四题" class="headerlink" title="第五十四题"></a>第五十四题</h3><p>三个方法。<br>方法一，直接keep住过往的node，然后对每一node检查是否访问过。O(n^2).</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isVisited</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; v, ListNode* node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v[i] == node) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ListNode* <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode* pHead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;ListNode*&gt; visited;</span><br><span class="line">    ListNode* node = pHead;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">NULL</span> &amp;&amp; !isVisited(visited, node)) &#123;</span><br><span class="line">        visited.push_back(node);</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二，每次访问之后，把前面的链接断掉。这样如果出现loop，则下一次访问时，next为null(ps: 不过这样会破坏原有的list). O(n)<br>方法三，先求出ring的长度a，然后让指针一先走a，指针b再走。则ab相遇时，一定在入口点。O(n)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode* pHead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// get the length of loop</span></span><br><span class="line">    <span class="comment">// Vptr1 = 2, Vptr2 = 1</span></span><br><span class="line">    <span class="keyword">if</span> (pHead == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (pHead-&gt;next == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (pHead-&gt;next-&gt;next == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    ListNode* ptr1 = pHead-&gt;next-&gt;next;</span><br><span class="line">    ListNode* ptr2 = pHead-&gt;next;</span><br><span class="line">    <span class="keyword">int</span> time = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (ptr1 != ptr2 &amp;&amp; ptr1 != <span class="literal">NULL</span> &amp;&amp; ptr2 != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ptr1 = ptr1-&gt;next;</span><br><span class="line">        ptr2 = ptr2-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (ptr1 != <span class="literal">NULL</span>) ptr1 = ptr1-&gt;next;</span><br><span class="line">        time += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ptr1 == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> lengthOfLoop = time;</span><br><span class="line">    ptr1 = pHead;</span><br><span class="line">    ptr2 = pHead;</span><br><span class="line">    <span class="comment">// move ptr1 to length of loop</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lengthOfLoop; i++) &#123;</span><br><span class="line">        ptr1 = ptr1-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (ptr1 != ptr2) &#123;</span><br><span class="line">        ptr1 = ptr1-&gt;next;</span><br><span class="line">        ptr2 = ptr2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ptr1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第五十五题"><a href="#第五十五题" class="headerlink" title="第五十五题"></a>第五十五题</h3><p>暖心题。比较简单。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">deleteDuplication</span><span class="params">(ListNode* pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pHead == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (pHead-&gt;next == <span class="literal">NULL</span>) <span class="keyword">return</span> pHead;</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span> (pHead != <span class="literal">NULL</span> &amp;&amp; pHead-&gt;val == pHead-&gt;next-&gt;val || (pHead-&gt;val == tmp)) &#123;</span><br><span class="line">            tmp = pHead-&gt;val;</span><br><span class="line">            pHead = pHead-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (pHead-&gt;next == <span class="literal">NULL</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pHead == <span class="literal">NULL</span> || pHead-&gt;val == tmp) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (pHead-&gt;next == <span class="literal">NULL</span>) <span class="keyword">return</span> pHead;</span><br><span class="line">        ListNode* node = pHead-&gt;next-&gt;next;</span><br><span class="line">        ListNode* pre = pHead;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node != <span class="literal">NULL</span> &amp;&amp; node-&gt;val == pre-&gt;next-&gt;val) &#123;</span><br><span class="line">                <span class="keyword">while</span> (node != <span class="literal">NULL</span> &amp;&amp; node-&gt;val == pre-&gt;next-&gt;val) &#123;</span><br><span class="line">                    node = node-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                pre-&gt;next = node;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> pre = pre-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (node != <span class="literal">NULL</span>) node = node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pHead;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="第五十六题"><a href="#第五十六题" class="headerlink" title="第五十六题"></a>第五十六题</h3><p>分类讨论，共有三种case，node是左子，右子，家长。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeLinkNode* <span class="title">GetNext</span><span class="params">(TreeLinkNode* pNode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pNode == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// case1 if node is leftchild</span></span><br><span class="line">    TreeLinkNode* parent = pNode-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (parent != <span class="literal">NULL</span> &amp;&amp; parent-&gt;left == pNode) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pNode-&gt;right == <span class="literal">NULL</span>) <span class="keyword">return</span> pNode-&gt;next;</span><br><span class="line">        TreeLinkNode* node = pNode-&gt;right;</span><br><span class="line">        <span class="keyword">while</span> (node-&gt;left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            node = node-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// case2 if node is rightchild</span></span><br><span class="line">    <span class="keyword">if</span>(parent != <span class="literal">NULL</span> &amp;&amp; parent-&gt;right == pNode) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pNode-&gt;right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            TreeLinkNode* node = pNode-&gt;right;</span><br><span class="line">            <span class="keyword">while</span> (node-&gt;left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                node = node-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeLinkNode* grandpa = parent-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (grandpa == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (grandpa-&gt;left == parent) <span class="keyword">return</span> grandpa;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// case3 if node has no parent</span></span><br><span class="line">    <span class="keyword">if</span> (parent == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pNode-&gt;right == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        TreeLinkNode* node = pNode-&gt;right;</span><br><span class="line">        <span class="keyword">while</span> (node-&gt;left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            node = node-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第五十七题"><a href="#第五十七题" class="headerlink" title="第五十七题"></a>第五十七题</h3><p>使用递归可以轻松解决。方法一，构建镜像，再比较是否相等。方法二，直接比较两个节点的左右是否对称。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mirror</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">NULL</span>) <span class="keyword">return</span> node;</span><br><span class="line">		TreeNode* n = <span class="keyword">new</span> TreeNode(node-&gt;val);</span><br><span class="line">		TreeNode* left = <span class="literal">NULL</span>;</span><br><span class="line">		TreeNode* right = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">if</span> (node-&gt;left != <span class="literal">NULL</span>) n-&gt;right = mirror(node-&gt;left);</span><br><span class="line">		<span class="keyword">if</span> (node-&gt;right != <span class="literal">NULL</span>) n-&gt;left = mirror(node-&gt;right);</span><br><span class="line">		<span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSame</span><span class="params">(TreeNode* root, TreeNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span> &amp;&amp; node == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root != <span class="literal">NULL</span> &amp;&amp; node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;val != node-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (isSame(root-&gt;left, node-&gt;left) &amp;&amp; isSame(root-&gt;right, node-&gt;right)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode* pRoot)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// build mirror</span></span><br><span class="line">        TreeNode* m = mirror(pRoot);</span><br><span class="line">        <span class="comment">// check if mirror is same with pRoot</span></span><br><span class="line">        <span class="keyword">return</span> isSame(pRoot, m);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="第五十八题"><a href="#第五十八题" class="headerlink" title="第五十八题"></a>第五十八题</h3><p>BFS即可。值得注意的是，如果要在bfs得到层数，需要改变queue的pop时机，每一次都pop一层。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; Print(TreeNode* pRoot) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">if</span> (pRoot == <span class="literal">NULL</span>) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="comment">// bfs</span></span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">    q.push(pRoot);</span><br><span class="line">    <span class="keyword">bool</span> odd = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        <span class="comment">// pop all node out of queue</span></span><br><span class="line">        <span class="keyword">int</span> size = q.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            TreeNode* node = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            tmp.push_back(node-&gt;val);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left != <span class="literal">NULL</span>) q.push(node-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right != <span class="literal">NULL</span>) q.push(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!odd) &#123;</span><br><span class="line">            reverse(tmp.begin(), tmp.end());</span><br><span class="line">        &#125;</span><br><span class="line">        res.push_back(tmp);</span><br><span class="line">        odd = !odd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第五十九题"><a href="#第五十九题" class="headerlink" title="第五十九题"></a>第五十九题</h3><p>同上一题一样。</p>
<h3 id="第六十题"><a href="#第六十题" class="headerlink" title="第六十题"></a>第六十题</h3><p>用dfs可以完成。值得注意的是，妥善使用c++中的引用可以很elegant的完成任务。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Serialize</span><span class="params">(TreeNode* root, <span class="built_in">string</span>&amp; str)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			str += <span class="string">"#"</span>;</span><br><span class="line">			str += <span class="string">","</span>;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		str += to_string(root-&gt;val);</span><br><span class="line">		str += <span class="string">","</span>;</span><br><span class="line">		Serialize(root-&gt;left, str);</span><br><span class="line">		Serialize(root-&gt;right, str);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">char</span>* <span class="title">Serialize</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">		<span class="built_in">string</span> str;</span><br><span class="line">		Serialize(root, str);</span><br><span class="line">		<span class="keyword">char</span>* res = <span class="keyword">new</span> <span class="keyword">char</span>[str.length()];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">			res[i] = str[i];</span><br><span class="line">		&#125;</span><br><span class="line">		res[str.length()<span class="number">-1</span>] = <span class="string">'\0'</span>;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>* ptr)</span> </span>&#123;</span><br><span class="line">        ++index;</span><br><span class="line">		<span class="keyword">if</span> (ptr[index] == <span class="string">'#'</span>) &#123;</span><br><span class="line">			++index;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="keyword">int</span> num = ptr[index++] - <span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">for</span> (; ptr[index] != <span class="string">','</span> &amp;&amp; ptr[index] != <span class="string">'#'</span>; index++) &#123;</span><br><span class="line">            num = <span class="number">10</span> * num + ptr[index] - <span class="string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* node = <span class="keyword">new</span> TreeNode(num);</span><br><span class="line">        node-&gt;left = dfs(ptr);</span><br><span class="line">        node-&gt;right = dfs(ptr);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">Deserialize</span><span class="params">(<span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line">        TreeNode* node = dfs(str);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">-1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="61-66"><a href="#61-66" class="headerlink" title="61 - 66"></a>61 - 66</h2><h3 id="第六十一题"><a href="#第六十一题" class="headerlink" title="第六十一题"></a>第六十一题</h3><p>使用dfs遍历即可。O(klogn)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left != <span class="literal">NULL</span> &amp;&amp; res == <span class="literal">NULL</span>) DFS(node-&gt;left);</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span> (count == target) res = node;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right != <span class="literal">NULL</span> &amp;&amp; res == <span class="literal">NULL</span>) DFS(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">KthNode</span><span class="params">(TreeNode* pRoot, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        target = k;</span><br><span class="line">        DFS(pRoot);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> target = <span class="number">0</span>;</span><br><span class="line">    TreeNode* res = <span class="literal">NULL</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="第六十二题"><a href="#第六十二题" class="headerlink" title="第六十二题"></a>第六十二题</h3><p>DFS</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left != <span class="literal">NULL</span> &amp;&amp; res == <span class="literal">NULL</span>) DFS(node-&gt;left);</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span> (count == target) res = node;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right != <span class="literal">NULL</span> &amp;&amp; res == <span class="literal">NULL</span>) DFS(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">KthNode</span><span class="params">(TreeNode* pRoot, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        target = k;</span><br><span class="line">        DFS(pRoot);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> target = <span class="number">0</span>;</span><br><span class="line">    TreeNode* res = <span class="literal">NULL</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="第六十三题"><a href="#第六十三题" class="headerlink" title="第六十三题"></a>第六十三题</h3><p>直接暴力排序即可</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        numstream.push_back(num);</span><br><span class="line">        sort(numstream.begin(), numstream.end());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">GetMedian</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = numstream.size();</span><br><span class="line">        <span class="keyword">if</span> (size%<span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">double</span> res = numstream[size/<span class="number">2</span>] + numstream[size/<span class="number">2</span><span class="number">-1</span>];</span><br><span class="line">            res /= <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> numstream[size/<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numstream;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="第六十四题"><a href="#第六十四题" class="headerlink" title="第六十四题"></a>第六十四题</h3><p>递归来做。简单随意。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMax</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; num, <span class="keyword">int</span> startPos, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxPos = startPos;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = startPos; i &lt; startPos + size &amp;&amp; i &lt; num.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num[maxPos] &lt; num[i]) maxPos = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxPos;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; maxInWindows(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; num, <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(num.empty()||size&gt;num.size()||size&lt;<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span> numptr = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= num.size() - size; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (numptr &lt; i) &#123;</span><br><span class="line">                numptr = findMax(num, i, size);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (num[i + size - <span class="number">1</span>] &gt; num[numptr]) numptr = i + size - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(num[numptr]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="第六十五题"><a href="#第六十五题" class="headerlink" title="第六十五题"></a>第六十五题</h3><p>递归。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPath</span><span class="params">(<span class="keyword">char</span>* matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">char</span>* str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">                visitedRow.clear();</span><br><span class="line">                visitedCol.clear();</span><br><span class="line">                <span class="keyword">if</span> (hasPathPos(matrix, rows, cols, i, j, str)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPathPos</span><span class="params">(<span class="keyword">char</span>* matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">char</span>* str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str[<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (visited(row, col)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (row &lt; <span class="number">0</span> || row &gt;= rows) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (col &lt; <span class="number">0</span> || col &gt;= cols) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; matrix[row*cols + col] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span> (matrix[row*cols + col] == str[<span class="number">0</span>]) &#123;</span><br><span class="line">            visitedRow.push_back(row);</span><br><span class="line">            visitedCol.push_back(col);</span><br><span class="line">            <span class="keyword">if</span> (hasPathPos(matrix, rows, cols, row+<span class="number">1</span>, col, str+<span class="number">1</span>)</span><br><span class="line">                || hasPathPos(matrix, rows, cols, row<span class="number">-1</span>, col, str+<span class="number">1</span>)</span><br><span class="line">                || hasPathPos(matrix, rows, cols, row, col+<span class="number">1</span>, str+<span class="number">1</span>)</span><br><span class="line">                || hasPathPos(matrix, rows, cols, row, col<span class="number">-1</span>, str+<span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            visitedRow.pop_back();</span><br><span class="line">            visitedCol.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">visited</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; visitedRow.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visitedRow[i] == row &amp;&amp; visitedCol[i] == col) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; visitedRow;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; visitedCol;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>第六十六题<br>递归。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;rows = rows;</span><br><span class="line">        <span class="keyword">this</span>-&gt;cols = cols;</span><br><span class="line">        matrix = <span class="keyword">new</span> <span class="keyword">bool</span>[rows*cols];</span><br><span class="line">        u = <span class="keyword">new</span> <span class="keyword">bool</span>[rows*cols];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">                u[i*cols + j] = calc(i, j, threshold);</span><br><span class="line">                matrix[i*cols+j] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m(<span class="number">0</span>, <span class="number">0</span>, threshold);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">m</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> threshold)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (row &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (row &gt;= rows) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (col &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (col &gt;= cols) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!matrix[row*cols + col]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (u[row*cols + col]) &#123;</span><br><span class="line">            matrix[row*cols + col] = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">int</span> up = m(row<span class="number">-1</span>, col, threshold);</span><br><span class="line">            <span class="keyword">int</span> down = m(row+<span class="number">1</span>, col, threshold);</span><br><span class="line">            <span class="keyword">int</span> left = m(row, col<span class="number">-1</span>, threshold);</span><br><span class="line">            <span class="keyword">int</span> right = m(row, col+<span class="number">1</span>, threshold);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + up + down + left + right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> th)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (row &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum += row % <span class="number">10</span>;</span><br><span class="line">            row /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (col &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum += col % <span class="number">10</span>;</span><br><span class="line">            col /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; sum &lt;&lt; <span class="string">" "</span> &lt;&lt; th &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> (sum &lt;= th);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">bool</span>* matrix;</span><br><span class="line">    <span class="keyword">bool</span>* u;</span><br><span class="line">    <span class="keyword">int</span> rows;</span><br><span class="line">    <span class="keyword">int</span> cols;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/26/career-plan/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李书赫">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404 Not Found">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/26/career-plan/" itemprop="url">校招准备</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-26T16:26:32+08:00">
                2019-06-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Checklist:</p>
<ul>
<li><input checked disabled type="checkbox"> 英文简历</li>
<li><input disabled type="checkbox"> 中文简历</li>
<li><input disabled type="checkbox"> 剑指offer (C/C++)</li>
<li><input disabled type="checkbox"> 暑期实习</li>
<li><input disabled type="checkbox"> 扫雷</li>
<li><input disabled type="checkbox"> 扫雷AI</li>
<li><input disabled type="checkbox"> Search Engine</li>
<li><input disabled type="checkbox"> C++ 基础知识巩固</li>
<li><input disabled type="checkbox"> JAVA 基础知识巩固</li>
<li><input disabled type="checkbox"> Python 基础知识巩固</li>
<li><input disabled type="checkbox"> 算法基础知识巩固</li>
<li><input disabled type="checkbox"> 阅读深入了解计算机系统</li>
<li><input disabled type="checkbox"> C++ primer</li>
<li><input disabled type="checkbox"> 数据库</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="李书赫">
            
              <p class="site-author-name" itemprop="name">李书赫</p>
              <p class="site-description motion-element" itemprop="description">It works on my machine</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">李书赫</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
  


  

  

</body>
</html>
